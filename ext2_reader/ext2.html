<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>The Second Extended File System</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="EXT2.INTERNALS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>The Second Extended File System</A
></H1
><H2
CLASS="SUBTITLE"
>Internal Layout</H2
><H3
CLASS="AUTHOR"
><A
NAME="AEN6"
></A
>Dave Poirier</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:instinc@gmail.com"
>instinc@gmail.com</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2001-2011 Dave Poirier</P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN15"
></A
><P
>	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1
	or any later version published by the Free Software Foundation;
	with no Invariant Sections, with no Front-Cover Texts, and with no
	Back-Cover Texts. A copy of the license can be acquired electronically
	from http://www.fsf.org/licenses/fdl.html or by writing to 
	59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   </P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN18"
>About this book</A
></DT
><DT
>1. <A
HREF="#HISTORY"
>Historical Background</A
></DT
><DT
>2. <A
HREF="#DEFINITIONS"
>Definitions</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#DEF-BLOCKS"
>Blocks</A
></DT
><DT
>2.2. <A
HREF="#DEF-BLOCK-GROUPS"
>Block Groups</A
></DT
><DT
>2.3. <A
HREF="#DEF-DIRECTORIES"
>Directories</A
></DT
><DT
>2.4. <A
HREF="#DEF-INODES"
>Inodes</A
></DT
><DT
>2.5. <A
HREF="#DEF-SUPERBLOCK"
>Superblocks</A
></DT
><DT
>2.6. <A
HREF="#DEF-SYMBOLIC-LINKS"
>Symbolic Links</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#DISK-ORGANISATION"
>Disk Organization</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#SUPERBLOCK"
>Superblock</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#S-INODES-COUNT"
>s_inodes_count</A
></DT
><DT
>3.1.2. <A
HREF="#S-BLOCKS-COUNT"
>s_blocks_count</A
></DT
><DT
>3.1.3. <A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
></DT
><DT
>3.1.4. <A
HREF="#S-FREE-BLOCKS-COUNT"
>s_free_blocks_count</A
></DT
><DT
>3.1.5. <A
HREF="#S-FREE-INODES-COUNT"
>s_free_inodes_count</A
></DT
><DT
>3.1.6. <A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
></DT
><DT
>3.1.7. <A
HREF="#S-LOG-BLOCK-SIZE"
>s_log_block_size</A
></DT
><DT
>3.1.8. <A
HREF="#S-LOG-FRAG-SIZE"
>s_log_frag_size</A
></DT
><DT
>3.1.9. <A
HREF="#S-BLOCKS-PER-GROUP"
>s_blocks_per_group</A
></DT
><DT
>3.1.10. <A
HREF="#S-FRAGS-PER-GROUP"
>s_frags_per_group</A
></DT
><DT
>3.1.11. <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
></DT
><DT
>3.1.12. <A
HREF="#S-MTIME"
>s_mtime</A
></DT
><DT
>3.1.13. <A
HREF="#S-WTIME"
>s_wtime</A
></DT
><DT
>3.1.14. <A
HREF="#S-MNT-COUNT"
>s_mnt_count</A
></DT
><DT
>3.1.15. <A
HREF="#S-MAX-MNT-COUNT"
>s_max_mnt_count</A
></DT
><DT
>3.1.16. <A
HREF="#S-MAGIC"
>s_magic</A
></DT
><DT
>3.1.17. <A
HREF="#S-STATE"
>s_state</A
></DT
><DT
>3.1.18. <A
HREF="#S-ERRORS"
>s_errors</A
></DT
><DT
>3.1.19. <A
HREF="#S-MINOR-REV-LEVEL"
>s_minor_rev_level</A
></DT
><DT
>3.1.20. <A
HREF="#S-LASTCHECK"
>s_lastcheck</A
></DT
><DT
>3.1.21. <A
HREF="#S-CHECKINTERVAL"
>s_checkinterval</A
></DT
><DT
>3.1.22. <A
HREF="#S-CREATOR-OS"
>s_creator_os</A
></DT
><DT
>3.1.23. <A
HREF="#S-REV-LEVEL"
>s_rev_level</A
></DT
><DT
>3.1.24. <A
HREF="#S-DEF-RESUID"
>s_def_resuid</A
></DT
><DT
>3.1.25. <A
HREF="#S-DEF-RESGID"
>s_def_resgid</A
></DT
><DT
>3.1.26. <A
HREF="#S-FIRST-INO"
>s_first_ino</A
></DT
><DT
>3.1.27. <A
HREF="#S-INODE-SIZE"
>s_inode_size</A
></DT
><DT
>3.1.28. <A
HREF="#S-BLOCK-GROUP-NR"
>s_block_group_nr</A
></DT
><DT
>3.1.29. <A
HREF="#S-FEATURE-COMPAT"
>s_feature_compat</A
></DT
><DT
>3.1.30. <A
HREF="#S-FEATURE-INCOMPAT"
>s_feature_incompat</A
></DT
><DT
>3.1.31. <A
HREF="#S-FEATURE-RO-COMPAT"
>s_feature_ro_compat</A
></DT
><DT
>3.1.32. <A
HREF="#S-UUID"
>s_uuid</A
></DT
><DT
>3.1.33. <A
HREF="#S-VOLUME-NAME"
>s_volume_name</A
></DT
><DT
>3.1.34. <A
HREF="#S-LAST-MOUNTED"
>s_last_mounted</A
></DT
><DT
>3.1.35. <A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
></DT
><DT
>3.1.36. <A
HREF="#S-PREALLOC-BLOCKS"
>s_prealloc_blocks</A
></DT
><DT
>3.1.37. <A
HREF="#S-PREALLOC-DIR-BLOCKS"
>s_prealloc_dir_blocks</A
></DT
><DT
>3.1.38. <A
HREF="#S-JOURNAL-UUID"
>s_journal_uuid</A
></DT
><DT
>3.1.39. <A
HREF="#S-JOURNAL-INUM"
>s_journal_inum</A
></DT
><DT
>3.1.40. <A
HREF="#S-JOURNAL-DEV"
>s_journal_dev</A
></DT
><DT
>3.1.41. <A
HREF="#S-LAST-ORPHAN"
>s_last_orphan</A
></DT
><DT
>3.1.42. <A
HREF="#S-HASH-SEED"
>s_hash_seed</A
></DT
><DT
>3.1.43. <A
HREF="#S-DEF-HASH-VERSION"
>s_def_hash_version</A
></DT
><DT
>3.1.44. <A
HREF="#S-DEFAULT-MOUNT-OPTIONS"
>s_default_mount_options</A
></DT
><DT
>3.1.45. <A
HREF="#S-FIRST-META-BG"
>s_first_meta_bg</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>Block Group Descriptor Table</A
></DT
><DD
><DL
><DT
>3.2.1. <A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
></DT
><DT
>3.2.2. <A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
></DT
><DT
>3.2.3. <A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
></DT
><DT
>3.2.4. <A
HREF="#BG-FREE-BLOCKS-COUNT"
>bg_free_blocks_count</A
></DT
><DT
>3.2.5. <A
HREF="#BG-FREE-INODES-COUNT"
>bg_free_inodes_count</A
></DT
><DT
>3.2.6. <A
HREF="#BG-USED-DIRS-COUNT"
>bg_used_dirs_count</A
></DT
><DT
>3.2.7. <A
HREF="#BG-PAD"
>bg_pad</A
></DT
><DT
>3.2.8. <A
HREF="#BG-RESERVED"
>bg_reserved</A
></DT
></DL
></DD
><DT
>3.3. <A
HREF="#BLOCK-BITMAP"
>Block Bitmap</A
></DT
><DT
>3.4. <A
HREF="#INODE-BITMAP"
>Inode Bitmap</A
></DT
><DT
>3.5. <A
HREF="#INODE-TABLE"
>Inode Table</A
></DT
><DD
><DL
><DT
>3.5.1. <A
HREF="#I-MODE"
>i_mode</A
></DT
><DT
>3.5.2. <A
HREF="#I-UID"
>i_uid</A
></DT
><DT
>3.5.3. <A
HREF="#I-SIZE"
>i_size</A
></DT
><DT
>3.5.4. <A
HREF="#I-ATIME"
>i_atime</A
></DT
><DT
>3.5.5. <A
HREF="#I-CTIME"
>i_ctime</A
></DT
><DT
>3.5.6. <A
HREF="#I-MTIME"
>i_mtime</A
></DT
><DT
>3.5.7. <A
HREF="#I-DTIME"
>i_dtime</A
></DT
><DT
>3.5.8. <A
HREF="#I-GID"
>i_gid</A
></DT
><DT
>3.5.9. <A
HREF="#I-LINKS-COUNT"
>i_links_count</A
></DT
><DT
>3.5.10. <A
HREF="#I-BLOCKS"
>i_blocks</A
></DT
><DT
>3.5.11. <A
HREF="#I-FLAGS"
>i_flags</A
></DT
><DT
>3.5.12. <A
HREF="#I-OSD1"
>i_osd1</A
></DT
><DT
>3.5.13. <A
HREF="#I-BLOCK"
>i_block</A
></DT
><DT
>3.5.14. <A
HREF="#I-GENERATION"
>i_generation</A
></DT
><DT
>3.5.15. <A
HREF="#I-FILE-ACL"
>i_file_acl</A
></DT
><DT
>3.5.16. <A
HREF="#I-DIR-ACL"
>i_dir_acl</A
></DT
><DT
>3.5.17. <A
HREF="#I-FADDR"
>i_faddr</A
></DT
><DT
>3.5.18. <A
HREF="#I-OSD2"
>Inode i_osd2 Structure</A
></DT
></DL
></DD
><DT
>3.6. <A
HREF="#AEN1729"
>Locating an Inode</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DIRECTORY"
>Directory Structure</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#LINKED-DIRECTORIES"
>Linked List Directory</A
></DT
><DD
><DL
><DT
>4.1.1. <A
HREF="#IFDIR-INODE"
>inode</A
></DT
><DT
>4.1.2. <A
HREF="#IFDIR-REC-LEN"
>rec_len</A
></DT
><DT
>4.1.3. <A
HREF="#IFDIR-NAME-LEN"
>name_len</A
></DT
><DT
>4.1.4. <A
HREF="#IFDIR-FILE-TYPE"
>file_type</A
></DT
><DT
>4.1.5. <A
HREF="#IFDIR-NAME"
>name</A
></DT
><DT
>4.1.6. <A
HREF="#DIR-SAMPLE"
>Sample Directory</A
></DT
></DL
></DD
><DT
>4.2. <A
HREF="#INDEXED-DIRECTORY"
>Indexed Directory Format</A
></DT
><DD
><DL
><DT
>4.2.1. <A
HREF="#DX-ROOT"
>Indexed Directory Root</A
></DT
><DT
>4.2.2. <A
HREF="#DX-ENTRY"
>Indexed Directory Entry</A
></DT
><DT
>4.2.3. <A
HREF="#CONTRIB-LOOKUP-ALGORITHM"
>Lookup Algorithm</A
></DT
><DT
>4.2.4. <A
HREF="#CONTRIB-INSERT-ALGORITHM"
>Insert Algorithm</A
></DT
><DT
>4.2.5. <A
HREF="#CONTRIB-SPLITTING"
>Splitting</A
></DT
><DT
>4.2.6. <A
HREF="#CONTRIB-KEY-COLLISIONS"
>Key Collisions</A
></DT
><DT
>4.2.7. <A
HREF="#CONTRIB-HASH-FUNCTION"
>Hash Function</A
></DT
><DT
>4.2.8. <A
HREF="#CONTRIB-PERFORMANCE"
>Performance</A
></DT
></DL
></DD
></DL
></DD
><DT
>5. <A
HREF="#AEN2393"
>File Attributes</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN2397"
>Standard Attributes</A
></DT
><DD
><DL
><DT
>5.1.1. <A
HREF="#AEN2399"
>SUID, SGID and -rwxrwxrwx</A
></DT
><DT
>5.1.2. <A
HREF="#AEN2403"
>File Size</A
></DT
><DT
>5.1.3. <A
HREF="#AEN2407"
>Owner and Group</A
></DT
></DL
></DD
><DT
>5.2. <A
HREF="#CONTRIB-EXTENDED-ATTRIBUTES"
>Extended Attributes</A
></DT
><DD
><DL
><DT
>5.2.1. <A
HREF="#EXTENDED-ATTRIBUTE-LAYOUT"
>Extended Attribute Block Layout</A
></DT
><DT
>5.2.2. <A
HREF="#ATTRIBUTE-BLOCK-HEADER"
>Extended Attribute Block Header</A
></DT
><DT
>5.2.3. <A
HREF="#AEN2540"
>Attribute Entry Header</A
></DT
></DL
></DD
><DT
>5.3. <A
HREF="#BEHAVIOUR-FLAGS"
>Behaviour Control Flags</A
></DT
><DD
><DL
><DT
>5.3.1. <A
HREF="#EXT2-SECRM-FL"
>EXT2_SECRM_FL - Secure Deletion</A
></DT
><DT
>5.3.2. <A
HREF="#EXT2-UNRM-FL"
>EXT2_UNRM_FL - Record for Undelete</A
></DT
><DT
>5.3.3. <A
HREF="#EXT2-COMPR-FL"
>EXT2_COMPR_FL - Compressed File</A
></DT
><DT
>5.3.4. <A
HREF="#EXT2-SYNC-FL"
>EXT2_SYNC_FL - Synchronous Updates</A
></DT
><DT
>5.3.5. <A
HREF="#EXT2-IMMUTABLE-FL"
>EXT2_IMMUTABLE_FL - Immutable File</A
></DT
><DT
>5.3.6. <A
HREF="#EXT2-APPEND-FL"
>EXT2_APPEND_FL - Append Only</A
></DT
><DT
>5.3.7. <A
HREF="#EXT2-NODUMP-FL"
>EXT2_NODUMP_FL - Do No Dump/Delete</A
></DT
><DT
>5.3.8. <A
HREF="#EXT2-NOATIME-FL"
>EXT2_NOATIME_FL - Do Not Update .i_atime</A
></DT
><DT
>5.3.9. <A
HREF="#EXT2-DIRTY-FL"
>EXT2_DIRTY_FL - Dirty</A
></DT
><DT
>5.3.10. <A
HREF="#EXT2-COMPRBLK-FL"
>EXT2_COMPRBLK_FL - Compressed Blocks</A
></DT
><DT
>5.3.11. <A
HREF="#EXT2-NOCOMPR-FL"
>EXT2_NOCOMPR_FL - Access Raw Compressed Data</A
></DT
><DT
>5.3.12. <A
HREF="#EXT2-ECOMPR-FL"
>EXT2_ECOMPR_FL - Compression Error</A
></DT
><DT
>5.3.13. <A
HREF="#EXT2-BTREE-FL"
>EXT2_BTREE_FL - B-Tree Format Directory</A
></DT
><DT
>5.3.14. <A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL - Hash Indexed Directory</A
></DT
><DT
>5.3.15. <A
HREF="#EXT2-IMAGIC-FL"
>EXT2_IMAGIC_FL -</A
></DT
><DT
>5.3.16. <A
HREF="#EXT3-JOURNAL-DATA-FL"
>EXT2_JOURNAL_DATA_FL - Journal File Data</A
></DT
><DT
>5.3.17. <A
HREF="#EXT2-RESERVED-FL"
>EXT2_RESERVED_FL - Reserved</A
></DT
></DL
></DD
></DL
></DD
><DT
>A. <A
HREF="#AEN2728"
>Credits</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>2-1. <A
HREF="#BLOCK-SIZE-IMPACT"
>Impact of Block Sizes</A
></DT
><DT
>3-1. <A
HREF="#DISK-LAYOUT-SAMPLE-FLOPPY"
>Sample Floppy Disk Layout, 1KiB blocks</A
></DT
><DT
>3-2. <A
HREF="#DISK-LAYOUT-SAMPLE-20MB"
>Sample 20mb Partition Layout</A
></DT
><DT
>3-3. <A
HREF="#SUPERBLOCK-STRUCTURE"
>Superblock Structure</A
></DT
><DT
>3-4. <A
HREF="#S-STATE-VALUES"
>Defined s_state Values</A
></DT
><DT
>3-5. <A
HREF="#EXT2-ERRORS"
>Defined s_errors Values</A
></DT
><DT
>3-6. <A
HREF="#S-CREATOR-OS-VALUES"
>Defined s_creator_os Values</A
></DT
><DT
>3-7. <A
HREF="#S-REV-LEVEL-VALUES"
>Defined s_rev_level Values</A
></DT
><DT
>3-8. <A
HREF="#S-FEATURE-COMPAT-VALUES"
>Defined s_feature_compat Values</A
></DT
><DT
>3-9. <A
HREF="#S-FEATURE-INCOMPAT-VALUES"
>Defined s_feature_incompat Values</A
></DT
><DT
>3-10. <A
HREF="#S-FEATURE-RO-COMPAT-VALUES"
>Defined s_feature_ro_compat Values</A
></DT
><DT
>3-11. <A
HREF="#S-ALGO-BITMAP-VALUES"
>Defined s_algo_bitmap Values</A
></DT
><DT
>3-12. <A
HREF="#BLOCK-GROUP-DESCRIPTOR-STRUCTURE"
>Block Group Descriptor Structure</A
></DT
><DT
>3-13. <A
HREF="#INODE-STRUCTURE"
>Inode Structure</A
></DT
><DT
>3-14. <A
HREF="#RESERVED-INODES-VALUES"
>Defined Reserved Inodes</A
></DT
><DT
>3-15. <A
HREF="#AEN1288"
>Defined i_mode Values</A
></DT
><DT
>3-16. <A
HREF="#DEFINED-I-FLAGS-VALUES"
>Defined i_flags Values</A
></DT
><DT
>3-17. <A
HREF="#I-OSD2-HURD-STRUCTURE"
>Inode i_osd2 Structure: Hurd</A
></DT
><DT
>3-18. <A
HREF="#I-OSD2-LINUX-STRUCTURE"
>Inode i_osd2 Structure: Linux</A
></DT
><DT
>3-19. <A
HREF="#I-OSD2-MASIX-STRUCTURE"
>Inode i_osd2 Structure: Masix</A
></DT
><DT
>3-20. <A
HREF="#INODE-COMPUTATION-SAMPLE"
>Sample Inode Computations</A
></DT
><DT
>4-1. <A
HREF="#LINKED-DIRECTORY-ENTRY-STRUCTURE"
>Linked Directory Entry Structure</A
></DT
><DT
>4-2. <A
HREF="#IFDIR-FILE-TYPE-VALUES"
>Defined Inode File Type Values</A
></DT
><DT
>4-3. <A
HREF="#SAMPLE-LINKED-DIRECTORY-DATA"
>Sample Linked Directory Data Layout, 4KiB blocks</A
></DT
><DT
>4-4. <A
HREF="#DX-ROOT-STRUCTURE"
>Indexed Directory Root Structure</A
></DT
><DT
>4-5. <A
HREF="#DEFINED-DX-HASH-VERSION-VALUES"
>Defined Indexed Directory Hash Versions</A
></DT
><DT
>4-6. <A
HREF="#DX-ENTRY-STRUCTURE"
>Indexed Directory Entry Structure (dx_entry)</A
></DT
><DT
>4-7. <A
HREF="#DX-ENTRY-COUNTLIMIT"
>Indexed Directory Entry Count and Limit Structure</A
></DT
><DT
>5-1. <A
HREF="#EXTENDED-ATTRIBUTE-BLOCK-LAYOUT"
>Extended Attribute Block Layout</A
></DT
><DT
>5-2. <A
HREF="#ATTRIBUTE-BLOCK-HEADER-STRUCTURE"
>ext2_xattr_header structure</A
></DT
><DT
>5-3. <A
HREF="#AEN2579"
>Behaviour Control Flags</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>4-1. <A
HREF="#AEN2384"
>Performance of Indexed Directories</A
></DT
><DT
>5-1. <A
HREF="#AEN2542"
>ext2_xattr_header structure</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="AEN18"
></A
>About this book</H1
><P
>	The latest version of this document may be downloaded from
	http://www.freesoftware.fsf.org/ext2-doc/
  </P
><P
>	This book is intended as an  introduction  and  guide  to  the  Second
	Extended File System, also known as Ext2.  The reader  should  have  a
	good understanding of the purpose of a file  system  as  well  as  the
	associated vocabulary (file, directory, partition, etc).
  </P
><P
>	Implementing file system drivers is already a daunting task, unfortunately
	except for tidbits of information here and there most of the documentation
	for the Second Extended Filesystem is in source files.
  </P
><P
>	Hopefully this document will fix this problem, may it be of help to as
	many of you as possible.
  </P
><P
>	<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Unless otherwise stated, all values  are  stored  in  little
	endian byte order.</I
></SPAN
>
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="HISTORY"
></A
>Chapter 1. Historical Background</H1
><P
>	Written by Remy Card, Theodore Ts'o and Stephen Tweedie as a major rewrite
	of the Extended Filesystem, it was first released to the public on January
	1993 as part of the Linux kernel.  One of its greatest achievement is the
	ability to extend the file system functionalities while maintaining the
	internal structures.  This allowed an easier development of the Third
	Extended Filesystem (ext3) and the Fourth Extended Filesystem (ext4).
  </P
><P
>	There are implementations available in most operating system including but
	not limited to NetBSD, FreeBSD, the GNU HURD, Microsoft Windows, IBM OS/2
	and RISC OS.
  </P
><P
>	Although newer file systems have been designed, such as Ext3 and Ext4, the
	Second Extended Filesystem is still prefered on flash drives as it requires
	fewer write operations (since it has no journal).  The structures of Ext3
	and Ext4 are based on Ext2 and add some additional options such as journaling,
	journal checksums, extents, online defragmentation, delayed allocations and
	larger directories to name but a few.
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DEFINITIONS"
></A
>Chapter 2. Definitions</H1
><P
>	The Second Extended Filesystem uses blocks as the basic unit of storage,
	inodes as the mean of keeping track of files and system objects, block groups
	to logically split the disk into more manageable sections, directories to
	provide a hierarchical organization of files, block and inode bitmaps to keep
	track of allocated blocks and inodes, and superblocks to define
	the parameters of the file system and its overall state.
  </P
><P
>	Ext2 shares many properties with traditional Unix filesystems.  It has space
	in the specification for Access Control Lists (ACLs), fragments, undeletion
	and compression.  There is also a versioning mechanism to allow new
	features (such as journalling) to be added in a maximally compatible
	manner; such as in Ext3 and Ext4.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-BLOCKS"
>2.1. Blocks</A
></H2
><P
>	A partition, disk, file or block device formated with a Second Extended
	Filesystem is divided into small groups of sectors called <SPAN
CLASS="QUOTE"
>"blocks"</SPAN
>.  These blocks are then grouped into larger units called block groups.
   </P
><P
>	The size of the blocks are usually determined when formatting the disk
	and will have an impact on performance, maximum file size, and maximum
	file system size.  Block sizes commonly implemented include 1KiB,
	2KiB, 4KiB and 8KiB although provisions in the superblock allow for
	block sizes as big as 1024 * (2^31)-1 (see
	<A
HREF="#S-LOG-BLOCK-SIZE"
>s_log_block_size</A
>).
   </P
><P
>	Depending on the implementation, some architectures may impose limits on
	which block sizes are supported.  For example, a Linux 2.6
	implementation on DEC Alpha uses blocks of 8KiB but the same
	implementation on a Intel 386 processor will support a maximum block
	size of 4KiB.
   </P
><DIV
CLASS="TABLE"
><A
NAME="BLOCK-SIZE-IMPACT"
></A
><P
><B
>Table 2-1. Impact of Block Sizes</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>Upper Limits</TH
><TH
>1KiB</TH
><TH
>2KiB</TH
><TH
>4KiB</TH
><TH
>8KiB</TH
></TR
></THEAD
><TBODY
><TR
><TD
>file system blocks</TD
><TD
>2,147,483,647</TD
><TD
>2,147,483,647</TD
><TD
>2,147,483,647</TD
><TD
>2,147,483,647</TD
></TR
><TR
><TD
>blocks per block group</TD
><TD
>8,192</TD
><TD
>16,384</TD
><TD
>32,768</TD
><TD
>65,536</TD
></TR
><TR
><TD
>inodes per block group</TD
><TD
>8,192</TD
><TD
>16,384</TD
><TD
>32,768</TD
><TD
>65,536</TD
></TR
><TR
><TD
>bytes per block group</TD
><TD
>8,388,608 (8MiB)</TD
><TD
>33,554,432 (32MiB)</TD
><TD
>134,217,728 (128MiB)</TD
><TD
>536,870,912 (512MiB)</TD
></TR
><TR
><TD
>file system size (real)</TD
><TD
>4,398,046,509,056 (4TiB)</TD
><TD
>8,796,093,018,112 (8TiB)</TD
><TD
>17,592,186,036,224 (16TiB)</TD
><TD
>35,184,372,080,640 (32TiB)</TD
></TR
><TR
><TD
>file system size (Linux)</TD
><TD
>2,199,023,254,528 (2TiB)
        <A
NAME="AEN86"
HREF="#FTN.AEN86"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
       </TD
><TD
>8,796,093,018,112 (8TiB)</TD
><TD
>17,592,186,036,224 (16TiB)</TD
><TD
>35,184,372,080,640 (32TiB)</TD
></TR
><TR
><TD
>blocks per file</TD
><TD
>16,843,020</TD
><TD
>134,217,728</TD
><TD
>1,074,791,436</TD
><TD
>8,594,130,956</TD
></TR
><TR
><TD
>file size (real)</TD
><TD
>17,247,252,480 (16GiB)</TD
><TD
>274,877,906,944 (256GiB)</TD
><TD
>2,199,023,255,552 (2TiB)</TD
><TD
>2,199,023,255,552 (2TiB)</TD
></TR
><TR
><TD
>file size (Linux 2.6.28)</TD
><TD
>17,247,252,480 (16GiB)</TD
><TD
>274,877,906,944 (256GiB)</TD
><TD
>2,199,023,255,552 (2TiB)</TD
><TD
>2,199,023,255,552 (2TiB)</TD
></TR
></TBODY
><TR
><TD
COLSPAN="5"
>Notes:<BR><A
NAME="FTN.AEN86"
>a. </A
>	This limit comes from the maximum size of a block device in
	Linux 2.4; it is unclear whether a Linux 2.6 kernel using a 1KiB block
	size could properly format and mount a Ext2 partition larger than 2TiB.
         <BR></TD
></TR
></TABLE
></DIV
><P
>	Note: the 2TiB file size is limited by the i_blocks value in the inode which indicates the number of 512-bytes sector rather than the actual number of ext2 blocks allocated.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-BLOCK-GROUPS"
>2.2. Block Groups</A
></H2
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>This definition comes from the Linux Kernel Documentation.</I
></P
></I
></TD
></TR
></TABLE
><P
>	Blocks are clustered into block groups in order to reduce fragmentation
	and minimise the amount of head seeking when reading a large amount
	of consecutive data.  Information about each block group is kept in a
	descriptor table stored in the block(s) immediately after the superblock.
	Two blocks near the start of each group are reserved for the block usage
	bitmap and the inode usage bitmap which show which blocks and inodes
	are in use.  Since each bitmap is limited to a single block, this means
	that the maximum size of a block group is 8 times the size of a block.
   </P
><P
>	The block(s) following the bitmaps in each block group are designated
	as the inode table for that block group and the remainder are the data
	blocks.  The block allocation algorithm attempts to allocate data blocks
	in the same block group as the inode which contains them.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-DIRECTORIES"
>2.3. Directories</A
></H2
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>This definition comes from the Linux Kernel Documentation with some minor
	alterations.</I
></P
></I
></TD
></TR
></TABLE
><P
>	A directory is a filesystem object and has an inode just like a file.
	It is a specially formatted file containing records which associate
	each name with an inode number.  Later revisions of the filesystem also
	encode the type of the object (file, directory, symlink, device, fifo,
	socket) to avoid the need to check the inode itself for this information
   </P
><P
>	The inode allocation code should try to assign inodes which are in the same
	block group as the directory in which they are first created.
   </P
><P
>	The original Ext2 revision used singly-linked list to store
	the filenames in the directory; newer revisions are able to use hashes
	and binary trees.
   </P
><P
>	Also note that as directory grows additional blocks are assigned to
	store the additional file records. When filenames are removed, some
	implementations do not free these additional blocks.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-INODES"
>2.4. Inodes</A
></H2
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>This definition comes from the Linux Kernel Documentation with some minor
	alterations.</I
></P
></I
></TD
></TR
></TABLE
><P
>	The inode (index node) is a fundamental concept in the ext2 filesystem.
	Each object in the filesystem is represented by an inode.  The inode
	structure contains pointers to the filesystem blocks which contain the
	data held in the object and all of the metadata about an object except
	its name.  The metadata about an object includes the permissions, owner,
	group, flags, size, number of blocks used, access time, change time,
	modification time, deletion time, number of links, fragments, version
	(for NFS) and extended attributes (EAs) and/or Access Control Lists (ACLs).
   </P
><P
>	There are some reserved fields which are currently unused in the inode
	structure and several which are overloaded.  One field is reserved for the
	directory ACL if the inode is a directory and alternately for the top 32
	bits of the file size if the inode is a regular file (allowing file sizes
	larger than 2GB).  The translator field is unused under Linux, but is used
	by the HURD to reference the inode of a program which will be used to
	interpret this object.  Most of the remaining reserved fields have been
	used up for both Linux and the HURD for larger owner and group fields,
	The HURD also has a larger mode field so it uses another of the remaining
	fields to store the extra bits.
   </P
><P
>	There are pointers to the first 12 blocks which contain the file's data
	in the inode.  There is a pointer to an indirect block (which contains
	pointers to the next set of blocks), a pointer to a doubly-indirect
	block (which contains pointers to indirect blocks) and a pointer to a
	trebly-indirect block (which contains pointers to doubly-indirect blocks).
   </P
><P
>	Some filesystem specific behaviour flags are also stored and allow for
	specific filesystem behaviour on a per-file basis. There are flags for
	secure deletion, undeletable, compression, synchronous updates,
	immutability, append-only, dumpable, no-atime, indexed directories, and
	data-journaling.
   </P
><P
>	Many of the filesystem specific behaviour flags, like journaling, have been
	implemented in newer filesystems like Ext3 and Ext4, while some other
	are still under development.
   </P
><P
>	All the inodes are stored in inode tables, with one inode table per block group.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-SUPERBLOCK"
>2.5. Superblocks</A
></H2
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>This definition comes from the Linux Kernel Documentation with some minor
	alterations.</I
></P
></I
></TD
></TR
></TABLE
><P
>	The superblock contains all the information about the configuration of
	the filesystem.  The information in the superblock contains fields
	such as the total number of inodes and blocks in the filesystem and how
	many are free, how many inodes and blocks are in each block group, when
	the filesystem was mounted (and if it was cleanly unmounted), when it
	was modified, what version of the filesystem it is and which OS created
	it.
   </P
><P
>	The primary copy of the superblock is stored at an offset of 1024 bytes
	from the start of the device, and it is essential to mounting the
	filesystem.  Since it is so important, backup copies of the superblock
	are stored in block groups throughout the filesystem.
   </P
><P
>	The first version of ext2 (revision 0) stores a copy at the start of
	every block group, along with backups of the group descriptor block(s).
	Because this can consume a considerable amount of space for large
	filesystems, later revisions can optionally reduce the number of backup
	copies by only putting backups in specific groups (this is the sparse
	superblock feature). The groups chosen are 0, 1 and powers of 3, 5 and 7.
   </P
><P
>	Revision 1 and higher of the filesystem also store extra fields, such as
	a volume name, a unique identification number, the inode size, and space
	for optional filesystem features to store configuration info.
   </P
><P
>	All fields in the superblock (as in all other ext2 structures) are stored
	on the disc in little endian format, so a filesystem is portable between
	machines without having to know what machine it was created on.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEF-SYMBOLIC-LINKS"
>2.6. Symbolic Links</A
></H2
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>This definition comes from Wikipedia.org with some minor
	alterations.</I
></P
></I
></TD
></TR
></TABLE
><P
>	A symbolic link (also symlink or soft link) is a special type of file that
	contains a reference to another file or directory in the form of an
	absolute or relative path and that affects pathname resolution.
   </P
><P
>	Symbolic links operate transparently for most operations: programs which
	read or write to files named by a symbolic link will behave as if
	operating directly on the target file.  However, programs that need to
	handle symbolic links specially (e.g., backup utilities) may identify
	and manipulate them directly.
   </P
><P
>	A symbolic link merely contains a text string that is interpreted and
	followed by the operating system as a path to another file or directory.
	It is a file on its own and can exist independently of its target.  The
	symbolic links do not affect an inode link count.  If a symbolic link is
	deleted, its target remains unaffected.  If the target is moved, renamed
	or deleted, any symbolic link that used to point to it continues to exist
	but now points to a non-existing file.  Symbolic links pointing to
	non-existing files are sometimes called <SPAN
CLASS="QUOTE"
>"orphaned"</SPAN
> or 
	<SPAN
CLASS="QUOTE"
>"dangling"</SPAN
>.
   </P
><P
>	Symbolic links are also filesystem objects with inodes.  For all symlink
	shorter than 60 bytes long, the data is stored within the inode itself; it
	uses the fields which would normally be used to store the pointers to data
	blocks. This is a worthwhile optimisation as it we avoid allocating a full
	block for the symlink, and most symlinks are less than 60 characters long.
   </P
><P
>	Symbolic links can also point to files or directories of other partitions
	and file systems.
   </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DISK-ORGANISATION"
></A
>Chapter 3. Disk Organization</H1
><P
>	An Ext2 file systems starts with a <A
HREF="#SUPERBLOCK"
>superblock</A
>
	located at byte offset 1024 from the start of the volume. This is block 1
	for a 1KiB block formatted volume or within block 0 for larger block sizes.  Note that the size of the superblock is constant regardless of the block size.
  </P
><P
>	On the next block(s) following the superblock, is the 
	Block Group Descriptor Table; which provides an overview of how the volume
	is split into block groups and where to find the inode bitmap, the block bitmap,
	and the inode table for each block group.
  </P
><P
>	In revision 0 of Ext2, each block group consists of a copy superblock, a copy of the
	block group descriptor table, a block bitmap, an inode bitmap, an inode table,
	and data blocks.
  </P
><P
>	With the introduction of revision 1 and the sparse superblock feature in Ext2,
	only specific block groups contain copies of the superblock and block group
	descriptor table.  All block groups still contain the block bitmap, inode
	bitmap, inode table, and data blocks.  The shadow copies of the superblock can
	be located in block groups 0, 1 and powers of 3, 5 and 7.
  </P
><P
>	The block bitmap and inode bitmap are limited to 1 block each per block group,
	so the total blocks per block group is therefore limited. (More information in
	the <A
HREF="#BLOCK-SIZE-IMPACT"
>Block Size Impact</A
> table).
  </P
><P
>	Each data block may also be further divided into <SPAN
CLASS="QUOTE"
>"fragments"</SPAN
>. As of
	Linux 2.6.28, support for fragment was still not implemented in the kernel;
	it is therefore suggested to ensure the fragment size is equal to the
	block size so as to maintain compatibility.
  </P
><DIV
CLASS="TABLE"
><A
NAME="DISK-LAYOUT-SAMPLE-FLOPPY"
></A
><P
><B
>Table 3-1. Sample Floppy Disk Layout, 1KiB blocks</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Block Offset</TH
><TH
>Length</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>byte 0</TD
><TD
>512 bytes</TD
><TD
>boot record (if present)</TD
></TR
><TR
><TD
>byte 512</TD
><TD
>512 bytes</TD
><TD
>additional boot record data (if present)</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- block group 0, blocks 1 to 1439 --</TD
></TR
><TR
><TD
>byte 1024</TD
><TD
>1024 bytes</TD
><TD
><A
HREF="#SUPERBLOCK"
>superblock</A
></TD
></TR
><TR
><TD
>block 2</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>block group descriptor table</A
></TD
></TR
><TR
><TD
>block 3</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-BITMAP"
>block bitmap</A
></TD
></TR
><TR
><TD
>block 4</TD
><TD
>1 block</TD
><TD
><A
HREF="#INODE-BITMAP"
>inode bitmap</A
></TD
></TR
><TR
><TD
>block 5</TD
><TD
>23 blocks</TD
><TD
><A
HREF="#INODE-TABLE"
>inode table</A
></TD
></TR
><TR
><TD
>block 28</TD
><TD
>1412 blocks</TD
><TD
>data blocks</TD
></TR
></TBODY
></TABLE
></DIV
><P
>	For the curious, block 0 always points to the first sector of the disk
	or partition and will always contain the boot record if one is present.
  </P
><P
>	The superblock is always located at byte offset 1024 from the start of
	the disk or partition.  In a 1KiB block-size formatted file system, this is
	block 1, but it will always be block 0 (at 1024 bytes within block 0) in
	larger block size file systems.
  </P
><P
>	And here's the organisation of a 20MB ext2 file system, using 1KiB blocks:
  </P
><DIV
CLASS="TABLE"
><A
NAME="DISK-LAYOUT-SAMPLE-20MB"
></A
><P
><B
>Table 3-2. Sample 20mb Partition Layout</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Block Offset</TH
><TH
>Length</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>byte 0</TD
><TD
>512 bytes</TD
><TD
>boot record (if present)</TD
></TR
><TR
><TD
>byte 512</TD
><TD
>512 bytes</TD
><TD
>additional boot record data (if present)</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- block group 0, blocks 1 to 8192 --</TD
></TR
><TR
><TD
>byte 1024</TD
><TD
>1024 bytes</TD
><TD
><A
HREF="#SUPERBLOCK"
>superblock</A
></TD
></TR
><TR
><TD
>block 2</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>block group descriptor table</A
></TD
></TR
><TR
><TD
>block 3</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-BITMAP"
>block bitmap</A
></TD
></TR
><TR
><TD
>block 4</TD
><TD
>1 block</TD
><TD
><A
HREF="#INODE-BITMAP"
>inode bitmap</A
></TD
></TR
><TR
><TD
>block 5</TD
><TD
>214 blocks</TD
><TD
><A
HREF="#INODE-TABLE"
>inode table</A
></TD
></TR
><TR
><TD
>block 219</TD
><TD
>7974 blocks</TD
><TD
>data blocks</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- block group 1, blocks 8193 to 16384 --</TD
></TR
><TR
><TD
>block 8193</TD
><TD
>1 block</TD
><TD
><A
HREF="#SUPERBLOCK"
>superblock</A
> backup</TD
></TR
><TR
><TD
>block 8194</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>block group descriptor table</A
> backup</TD
></TR
><TR
><TD
>block 8195</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-BITMAP"
>block bitmap</A
></TD
></TR
><TR
><TD
>block 8196</TD
><TD
>1 block</TD
><TD
><A
HREF="#INODE-BITMAP"
>inode bitmap</A
></TD
></TR
><TR
><TD
>block 8197</TD
><TD
>214 blocks</TD
><TD
><A
HREF="#INODE-TABLE"
>inode table</A
></TD
></TR
><TR
><TD
>block 8408</TD
><TD
>7974 blocks</TD
><TD
>data blocks</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- block group 2, blocks 16385 to 24576 --</TD
></TR
><TR
><TD
>block 16385</TD
><TD
>1 block</TD
><TD
><A
HREF="#BLOCK-BITMAP"
>block bitmap</A
></TD
></TR
><TR
><TD
>block 16386</TD
><TD
>1 block</TD
><TD
><A
HREF="#INODE-BITMAP"
>inode bitmap</A
></TD
></TR
><TR
><TD
>block 16387</TD
><TD
>214 blocks</TD
><TD
><A
HREF="#INODE-TABLE"
>inode table</A
></TD
></TR
><TR
><TD
>block 16601</TD
><TD
>3879 blocks</TD
><TD
>data blocks</TD
></TR
></TBODY
></TABLE
></DIV
><P
>	The layout on disk is very predictable as long as you know a few basic
	information; block size, blocks per  group,  inodes  per  group.  This
	information  is  all  located  in,  or  can  be  computed  from,   the
	<CODE
CLASS="STRUCTNAME"
>superblock</CODE
> structure.
  </P
><P
>	Nevertheless, unless the image was crafted with controlled parameters,
	the position of the various structures on disk (except the superblock)
	should never be assumed.  Always load the superblock first.
  </P
><P
>	Notice how block 0 is not part of the block group 0 in 1KiB block
	size file systems.  The reason for this is block group 0 always starts
	with the block containing the superblock.  Hence, on 1KiB block systems,
	block group 0 starts at block 1, but on larger block sizes it starts on
	block 0.  For more information, see the
	<A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
> superblock
	entry.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SUPERBLOCK"
>3.1. Superblock</A
></H2
><P
>	The <A
HREF="#DEF-SUPERBLOCK"
>superblock</A
> is always located at
	byte offset 1024 from the beginning of the file, block device or
	partition formatted with Ext2 and later variants (Ext3, Ext4).
   </P
><P
>	Its structure is mostly constant from Ext2 to Ext3 and Ext4 with only
	some minor changes.
   </P
><DIV
CLASS="TABLE"
><A
NAME="SUPERBLOCK-STRUCTURE"
></A
><P
><B
>Table 3-3. Superblock Structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>4</TD
><TD
><A
HREF="#S-INODES-COUNT"
>s_inodes_count</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>4</TD
><TD
><A
HREF="#S-BLOCKS-COUNT"
>s_blocks_count</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
><A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
></TD
></TR
><TR
><TD
>12</TD
><TD
>4</TD
><TD
><A
HREF="#S-FREE-BLOCKS-COUNT"
>s_free_blocks_count</A
></TD
></TR
><TR
><TD
>16</TD
><TD
>4</TD
><TD
><A
HREF="#S-FREE-INODES-COUNT"
>s_free_inodes_count</A
></TD
></TR
><TR
><TD
>20</TD
><TD
>4</TD
><TD
><A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
></TD
></TR
><TR
><TD
>24</TD
><TD
>4</TD
><TD
><A
HREF="#S-LOG-BLOCK-SIZE"
>s_log_block_size</A
></TD
></TR
><TR
><TD
>28</TD
><TD
>4</TD
><TD
><A
HREF="#S-LOG-FRAG-SIZE"
>s_log_frag_size</A
></TD
></TR
><TR
><TD
>32</TD
><TD
>4</TD
><TD
><A
HREF="#S-BLOCKS-PER-GROUP"
>s_blocks_per_group</A
></TD
></TR
><TR
><TD
>36</TD
><TD
>4</TD
><TD
><A
HREF="#S-FRAGS-PER-GROUP"
>s_frags_per_group</A
></TD
></TR
><TR
><TD
>40</TD
><TD
>4</TD
><TD
><A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
></TD
></TR
><TR
><TD
>44</TD
><TD
>4</TD
><TD
><A
HREF="#S-MTIME"
>s_mtime</A
></TD
></TR
><TR
><TD
>48</TD
><TD
>4</TD
><TD
><A
HREF="#S-WTIME"
>s_wtime</A
></TD
></TR
><TR
><TD
>52</TD
><TD
>2</TD
><TD
><A
HREF="#S-MNT-COUNT"
>s_mnt_count</A
></TD
></TR
><TR
><TD
>54</TD
><TD
>2</TD
><TD
><A
HREF="#S-MAX-MNT-COUNT"
>s_max_mnt_count</A
></TD
></TR
><TR
><TD
>56</TD
><TD
>2</TD
><TD
><A
HREF="#S-MAGIC"
>s_magic</A
></TD
></TR
><TR
><TD
>58</TD
><TD
>2</TD
><TD
><A
HREF="#S-STATE"
>s_state</A
></TD
></TR
><TR
><TD
>60</TD
><TD
>2</TD
><TD
><A
HREF="#S-ERRORS"
>s_errors</A
></TD
></TR
><TR
><TD
>62</TD
><TD
>2</TD
><TD
><A
HREF="#S-MINOR-REV-LEVEL"
>s_minor_rev_level</A
></TD
></TR
><TR
><TD
>64</TD
><TD
>4</TD
><TD
><A
HREF="#S-LASTCHECK"
>s_lastcheck</A
></TD
></TR
><TR
><TD
>68</TD
><TD
>4</TD
><TD
><A
HREF="#S-CHECKINTERVAL"
>s_checkinterval</A
></TD
></TR
><TR
><TD
>72</TD
><TD
>4</TD
><TD
><A
HREF="#S-CREATOR-OS"
>s_creator_os</A
></TD
></TR
><TR
><TD
>76</TD
><TD
>4</TD
><TD
><A
HREF="#S-REV-LEVEL"
>s_rev_level</A
></TD
></TR
><TR
><TD
>80</TD
><TD
>2</TD
><TD
><A
HREF="#S-DEF-RESUID"
>s_def_resuid</A
></TD
></TR
><TR
><TD
>82</TD
><TD
>2</TD
><TD
><A
HREF="#S-DEF-RESGID"
>s_def_resgid</A
></TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- EXT2_DYNAMIC_REV Specific --</TD
></TR
><TR
><TD
>84</TD
><TD
>4</TD
><TD
><A
HREF="#S-FIRST-INO"
>s_first_ino</A
></TD
></TR
><TR
><TD
>88</TD
><TD
>2</TD
><TD
><A
HREF="#S-INODE-SIZE"
>s_inode_size</A
></TD
></TR
><TR
><TD
>90</TD
><TD
>2</TD
><TD
><A
HREF="#S-BLOCK-GROUP-NR"
>s_block_group_nr</A
></TD
></TR
><TR
><TD
>92</TD
><TD
>4</TD
><TD
><A
HREF="#S-FEATURE-COMPAT"
>s_feature_compat</A
></TD
></TR
><TR
><TD
>96</TD
><TD
>4</TD
><TD
><A
HREF="#S-FEATURE-INCOMPAT"
>s_feature_incompat</A
></TD
></TR
><TR
><TD
>100</TD
><TD
>4</TD
><TD
><A
HREF="#S-FEATURE-RO-COMPAT"
>s_feature_ro_compat</A
></TD
></TR
><TR
><TD
>104</TD
><TD
>16</TD
><TD
><A
HREF="#S-UUID"
>s_uuid</A
></TD
></TR
><TR
><TD
>120</TD
><TD
>16</TD
><TD
><A
HREF="#S-VOLUME-NAME"
>s_volume_name</A
></TD
></TR
><TR
><TD
>136</TD
><TD
>64</TD
><TD
><A
HREF="#S-LAST-MOUNTED"
>s_last_mounted</A
></TD
></TR
><TR
><TD
>200</TD
><TD
>4</TD
><TD
><A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
></TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Performance Hints --</TD
></TR
><TR
><TD
>204</TD
><TD
>1</TD
><TD
><A
HREF="#S-PREALLOC-BLOCKS"
>s_prealloc_blocks</A
></TD
></TR
><TR
><TD
>205</TD
><TD
>1</TD
><TD
><A
HREF="#S-PREALLOC-DIR-BLOCKS"
>s_prealloc_dir_blocks</A
></TD
></TR
><TR
><TD
>206</TD
><TD
>2</TD
><TD
>(alignment)</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Journaling Support --</TD
></TR
><TR
><TD
>208</TD
><TD
>16</TD
><TD
><A
HREF="#S-JOURNAL-UUID"
>s_journal_uuid</A
></TD
></TR
><TR
><TD
>224</TD
><TD
>4</TD
><TD
><A
HREF="#S-JOURNAL-INUM"
>s_journal_inum</A
></TD
></TR
><TR
><TD
>228</TD
><TD
>4</TD
><TD
><A
HREF="#S-JOURNAL-DEV"
>s_journal_dev</A
></TD
></TR
><TR
><TD
>232</TD
><TD
>4</TD
><TD
><A
HREF="#S-LAST-ORPHAN"
>s_last_orphan</A
></TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Directory Indexing Support --</TD
></TR
><TR
><TD
>236</TD
><TD
>4 x 4</TD
><TD
><A
HREF="#S-HASH-SEED"
>s_hash_seed</A
></TD
></TR
><TR
><TD
>252</TD
><TD
>1</TD
><TD
><A
HREF="#S-DEF-HASH-VERSION"
>s_def_hash_version</A
></TD
></TR
><TR
><TD
>253</TD
><TD
>3</TD
><TD
>padding - reserved for future expansion</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Other options --</TD
></TR
><TR
><TD
>256</TD
><TD
>4</TD
><TD
><A
HREF="#S-DEFAULT-MOUNT-OPTIONS"
>s_default_mount_options</A
></TD
></TR
><TR
><TD
>260</TD
><TD
>4</TD
><TD
><A
HREF="#S-FIRST-META-BG"
>s_first_meta_bg</A
></TD
></TR
><TR
><TD
>264</TD
><TD
>760</TD
><TD
>Unused - reserved for future revisions</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-INODES-COUNT"
>3.1.1. s_inodes_count</A
></H3
><P
>	32bit value indicating the total number of inodes, both used and free,
	in the file system.  This value must be lower or equal to
	(s_inodes_per_group * number of block groups).  It must be equal to the
	sum of the inodes defined in each block group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-BLOCKS-COUNT"
>3.1.2. s_blocks_count</A
></H3
><P
>	32bit value indicating the total number of blocks in the system including
	all used, free and reserved. This value must be lower or equal to
	(s_blocks_per_group * number of block groups). It must be equal to the
	sum of the blocks defined in each block group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-R-BLOCKS-COUNT"
>3.1.3. s_r_blocks_count</A
></H3
><P
>	32bit value indicating the total number of  blocks  reserved  for  the
	usage of the super user.  This is most useful if  for  some  reason  a
	user, maliciously or not, fill the file system to capacity; the  super
	user will have this specified amount of free blocks at his disposal so
	he can edit and save configuration files.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FREE-BLOCKS-COUNT"
>3.1.4. s_free_blocks_count</A
></H3
><P
>	32bit value indicating the total number of free blocks, including  the
	number of reserved blocks (see
	<A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
>).  This is a  sum
	of all free blocks of all the block groups.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FREE-INODES-COUNT"
>3.1.5. s_free_inodes_count</A
></H3
><P
>	32bit value indicating the total number of free inodes.  This is a sum
	of all free inodes of all the block groups.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FIRST-DATA-BLOCK"
>3.1.6. s_first_data_block</A
></H3
><P
>	32bit value identifying the first data block, in other word the id  of
	the block containing the <CODE
CLASS="STRUCTNAME"
>superblock</CODE
> structure.
    </P
><P
>	Note that this value is always 0 for file systems with  a  block  size
	larger than 1KB, and always 1 for file systems with a  block  size  of
	1KB.  The <CODE
CLASS="STRUCTNAME"
>superblock</CODE
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>always</I
></SPAN
> starting at
	the 1024th byte of the disk, which normally happens to  be  the  first
	byte of the 3rd sector.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-LOG-BLOCK-SIZE"
>3.1.7. s_log_block_size</A
></H3
><P
>	The block size is computed using this 32bit value  as  the  number  of
	bits to shift left the value 1024.  This value may only be positive.
    </P
><PRE
CLASS="PROGRAMLISTING"
>block size = 1024 &lt;&lt; s_log_block_size;
    </PRE
><P
>	Common block sizes include 1KiB, 2KiB, 4KiB and 8Kib. For information
	about the impact of selecting a block size, see
	<A
HREF="#BLOCK-SIZE-IMPACT"
>Impact of Block Sizes</A
>.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux, at least up to 2.6.28, the block size must be at least as
	large as the sector size of the block device, and cannot be larger than
	the supported memory page of the architecture.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-LOG-FRAG-SIZE"
>3.1.8. s_log_frag_size</A
></H3
><P
>	The fragment size is computed using this 32bit value as the number  of
	bits to shift left the value 1024.  Note that a negative  value  would
	shift the bit right rather than left.
    </P
><PRE
CLASS="PROGRAMLISTING"
>if( positive )
  fragmnet size = 1024 &lt;&lt; s_log_frag_size;
else
  framgnet size = 1024 &gt;&gt; -s_log_frag_size;
    </PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	As of Linux 2.6.28 no support exists for an Ext2
	partition with fragment size smaller than the block size, as this feature
	seems to not be available.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-BLOCKS-PER-GROUP"
>3.1.9. s_blocks_per_group</A
></H3
><P
>	32bit value indicating the total number  of  blocks  per  group.  This
	value in combination with
	<A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
> can  be  used
	to determine the block groups boundaries.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FRAGS-PER-GROUP"
>3.1.10. s_frags_per_group</A
></H3
><P
>	32bit value indicating the total number of fragments per group.  It is
	also used to determine the size of the <CODE
CLASS="STRUCTNAME"
>block bitmap</CODE
>  of
	each block group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-INODES-PER-GROUP"
>3.1.11. s_inodes_per_group</A
></H3
><P
>	32bit value indicating the total number of inodes per group.  This  is
	also used to determine the size of the <CODE
CLASS="STRUCTNAME"
>inode bitmap</CODE
>  of
	each block group.  Note that you cannot have more than
	(block size in bytes * 8) inodes per group as the inode bitmap
	must fit within a single block. This value must be a perfect multiple
	of the number of inodes that can fit in a block
	((1024&lt;&lt;s_log_block_size)/s_inode_size).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-MTIME"
>3.1.12. s_mtime</A
></H3
><P
>	Unix time, as defined by POSIX, of the last time the file  system  was
	mounted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-WTIME"
>3.1.13. s_wtime</A
></H3
><P
>	Unix time, as defined by POSIX, of the last write access to  the  file
	system.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-MNT-COUNT"
>3.1.14. s_mnt_count</A
></H3
><P
>	32bit value indicating how many  time  the  file  system  was  mounted
	since the last time it was fully verified.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-MAX-MNT-COUNT"
>3.1.15. s_max_mnt_count</A
></H3
><P
>	32bit value indicating the maximum  number  of  times  that  the  file
	system may be mounted before a full check is performed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-MAGIC"
>3.1.16. s_magic</A
></H3
><P
>	16bit value  identifying  the  file  system  as  Ext2.  The  value  is
	currently fixed to <CODE
CLASS="CONSTANT"
>EXT2_SUPER_MAGIC</CODE
> of value 0xEF53.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-STATE"
>3.1.17. s_state</A
></H3
><P
>	16bit value indicating the file system state.  When the file system is
	mounted, this state is set  to  <CODE
CLASS="CONSTANT"
>EXT2_ERROR_FS</CODE
>.  After the
	file system was cleanly unmounted, this value is set to <CODE
CLASS="CONSTANT"
>EXT2_VALID_FS</CODE
>.
    </P
><P
>	When mounting the file system, if a valid of <CODE
CLASS="CONSTANT"
>EXT2_ERROR_FS</CODE
> is
	encountered it means the file system was not cleanly unmounted and most
	likely contain errors that will need to be fixed.  Typically under Linux
	this means running fsck.
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-STATE-VALUES"
></A
><P
><B
>Table 3-4. Defined s_state Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_VALID_FS</TD
><TD
>1</TD
><TD
>Unmounted cleanly</TD
></TR
><TR
><TD
>EXT2_ERROR_FS</TD
><TD
>2</TD
><TD
>Errors detected</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-ERRORS"
>3.1.18. s_errors</A
></H3
><P
>	16bit value indicating what the file system driver should do  when  an
	error is detected.  The following values have been defined:
    </P
><DIV
CLASS="TABLE"
><A
NAME="EXT2-ERRORS"
></A
><P
><B
>Table 3-5. Defined s_errors Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_ERRORS_CONTINUE</TD
><TD
>1</TD
><TD
>continue as if nothing happened</TD
></TR
><TR
><TD
>EXT2_ERRORS_RO</TD
><TD
>2</TD
><TD
>remount read-only</TD
></TR
><TR
><TD
>EXT2_ERRORS_PANIC</TD
><TD
>3</TD
><TD
>cause a kernel panic</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-MINOR-REV-LEVEL"
>3.1.19. s_minor_rev_level</A
></H3
><P
>	16bit value identifying the minor revision level within its
	<A
HREF="#S-REV-LEVEL"
>revision level</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-LASTCHECK"
>3.1.20. s_lastcheck</A
></H3
><P
>	Unix time, as defined by POSIX, of the last file system check.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-CHECKINTERVAL"
>3.1.21. s_checkinterval</A
></H3
><P
>	Maximum Unix time interval, as defined by POSIX, allowed between file
	system checks.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-CREATOR-OS"
>3.1.22. s_creator_os</A
></H3
><P
>	32bit identifier of the os that created the file system.  Defined
	values are:
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-CREATOR-OS-VALUES"
></A
><P
><B
>Table 3-6. Defined s_creator_os Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_OS_LINUX</TD
><TD
>0</TD
><TD
>Linux</TD
></TR
><TR
><TD
>EXT2_OS_HURD</TD
><TD
>1</TD
><TD
>GNU HURD</TD
></TR
><TR
><TD
>EXT2_OS_MASIX</TD
><TD
>2</TD
><TD
>MASIX</TD
></TR
><TR
><TD
>EXT2_OS_FREEBSD</TD
><TD
>3</TD
><TD
>FreeBSD</TD
></TR
><TR
><TD
>EXT2_OS_LITES</TD
><TD
>4</TD
><TD
>Lites</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-REV-LEVEL"
>3.1.23. s_rev_level</A
></H3
><P
>	32bit revision level value.
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-REV-LEVEL-VALUES"
></A
><P
><B
>Table 3-7. Defined s_rev_level Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_GOOD_OLD_REV</TD
><TD
>0</TD
><TD
>Revision 0</TD
></TR
><TR
><TD
>EXT2_DYNAMIC_REV</TD
><TD
>1</TD
><TD
>Revision 1 with variable inode sizes, extended attributes, etc.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-DEF-RESUID"
>3.1.24. s_def_resuid</A
></H3
><P
>	16bit value used as the default user id for reserved blocks.  
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux this defaults to <CODE
CLASS="CONSTANT"
>EXT2_DEF_RESUID</CODE
> of 0.
    </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-DEF-RESGID"
>3.1.25. s_def_resgid</A
></H3
><P
>	16bit value used as the default group id for reserved blocks.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux this defaults to <CODE
CLASS="CONSTANT"
>EXT2_DEF_RESGID</CODE
> of 0.
    </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FIRST-INO"
>3.1.26. s_first_ino</A
></H3
><P
>	32bit value used as index to the  first  inode  useable  for  standard
	files. In revision 0, the first	non-reserved inode is fixed to
	11 (<CODE
CLASS="CONSTANT"
>EXT2_GOOD_OLD_FIRST_INO</CODE
>). In revision 1 and later
	this value may be set to any value.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-INODE-SIZE"
>3.1.27. s_inode_size</A
></H3
><P
>	16bit value indicating the size of the inode structure. In revision 0, this
	value is always 128 (<CODE
CLASS="CONSTANT"
>EXT2_GOOD_OLD_INODE_SIZE</CODE
>). In revision 1
	and later, this value must be a perfect power of 2 and must be smaller or
	equal to the block size (1&lt;&lt;s_log_block_size).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-BLOCK-GROUP-NR"
>3.1.28. s_block_group_nr</A
></H3
><P
>	16bit value used to indicate the block group number hosting this
	superblock structure.  This can be used to rebuild the file system
	from any superblock backup.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FEATURE-COMPAT"
>3.1.29. s_feature_compat</A
></H3
><P
>	32bit bitmask of compatible features.  The file system implementation
	is free to support them or not without risk of damaging the meta-data.
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-FEATURE-COMPAT-VALUES"
></A
><P
><B
>Table 3-8. Defined s_feature_compat Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_COMPAT_DIR_PREALLOC</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0001</TD
><TD
>Block pre-allocation for new directories</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_COMPAT_IMAGIC_INODES</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0002</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT3_FEATURE_COMPAT_HAS_JOURNAL</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0004</TD
><TD
>An Ext3 journal exists</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_COMPAT_EXT_ATTR</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0008</TD
><TD
>Extended inode attributes are present</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_COMPAT_RESIZE_INO</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0010</TD
><TD
>Non-standard inode size used</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_COMPAT_DIR_INDEX</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0020</TD
><TD
>Directory indexing (HTree)</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FEATURE-INCOMPAT"
>3.1.30. s_feature_incompat</A
></H3
><P
>	32bit bitmask of incompatible features.  The file system
	implementation should refuse to mount the file system if any of
	the indicated feature is unsupported.
    </P
><P
>	An implementation not supporting these features would be unable to
	properly use the file system.  For example, if compression is being
	used and an executable file would be unusable after being read from
	the disk if the system does not know how to uncompress it.
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-FEATURE-INCOMPAT-VALUES"
></A
><P
><B
>Table 3-9. Defined s_feature_incompat Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_INCOMPAT_COMPRESSION</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0001</TD
><TD
>Disk/File compression is used</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_INCOMPAT_FILETYPE</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0002</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT3_FEATURE_INCOMPAT_RECOVER</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0004</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT3_FEATURE_INCOMPAT_JOURNAL_DEV</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0008</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_INCOMPAT_META_BG</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0010</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FEATURE-RO-COMPAT"
>3.1.31. s_feature_ro_compat</A
></H3
><P
>	32bit bitmask of <SPAN
CLASS="QUOTE"
>"read-only"</SPAN
> features.  The file system
	implementation should mount as read-only if any of the indicated
	feature is unsupported.
    </P
><DIV
CLASS="TABLE"
><A
NAME="S-FEATURE-RO-COMPAT-VALUES"
></A
><P
><B
>Table 3-10. Defined s_feature_ro_compat Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0001</TD
><TD
>Sparse Superblock</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_RO_COMPAT_LARGE_FILE</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0002</TD
><TD
>Large file support, 64-bit file size</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>EXT2_FEATURE_RO_COMPAT_BTREE_DIR</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>0x0004</TD
><TD
>Binary tree sorted directory files</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-UUID"
>3.1.32. s_uuid</A
></H3
><P
>	128bit value used as the volume id.  This should, as much as possible,
	be unique for each file system formatted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-VOLUME-NAME"
>3.1.33. s_volume_name</A
></H3
><P
>	16 bytes volume name, mostly unusued.  A valid volume name would consist
	of only ISO-Latin-1 characters and be 0 terminated.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-LAST-MOUNTED"
>3.1.34. s_last_mounted</A
></H3
><P
>	64 bytes directory path where the file system was last mounted.  While
	not normally used, it could serve for auto-finding the mountpoint when
	not indicated on the command line. Again the path should be zero
	terminated for compatibility reasons.  Valid path is constructed from
	ISO-Latin-1 characters.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-ALGO-BITMAP"
>3.1.35. s_algo_bitmap</A
></H3
><P
>	32bit value used by compression algorithms to determine the compression
	method(s) used.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Compression is supported in Linux 2.4 and 2.6 via the e2compr patch. For
	more information, visit http://e2compr.sourceforge.net/
    </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="S-ALGO-BITMAP-VALUES"
></A
><P
><B
>Table 3-11. Defined s_algo_bitmap Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Bit Number</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_LZV1_ALG</TD
><TD
>0</TD
><TD
>Binary value of 0x00000001</TD
></TR
><TR
><TD
>EXT2_LZRW3A_ALG</TD
><TD
>1</TD
><TD
>Binary value of 0x00000002</TD
></TR
><TR
><TD
>EXT2_GZIP_ALG</TD
><TD
>2</TD
><TD
>Binary value of 0x00000004</TD
></TR
><TR
><TD
>EXT2_BZIP2_ALG</TD
><TD
>3</TD
><TD
>Binary value of 0x00000008</TD
></TR
><TR
><TD
>EXT2_LZO_ALG</TD
><TD
>4</TD
><TD
>Binary value of 0x00000010</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-PREALLOC-BLOCKS"
>3.1.36. s_prealloc_blocks</A
></H3
><P
>	8-bit value representing the number of blocks the implementation should
	attempt to pre-allocate when creating a new regular file.  
    </P
><P
>	Linux 2.6.28 will only perform pre-allocation using Ext4 although no
	problem is expected if any version of Linux encounters a file with more
	blocks present than required.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-PREALLOC-DIR-BLOCKS"
>3.1.37. s_prealloc_dir_blocks</A
></H3
><P
>	8-bit value representing the number of blocks the implementation should
	attempt to pre-allocate when creating a new directory.
    </P
><P
>	Linux 2.6.28 will only perform pre-allocation using Ext4 and only if
	the <CODE
CLASS="CONSTANT"
>EXT4_FEATURE_COMPAT_DIR_PREALLOC</CODE
> flag is present. Since
	Linux does not de-allocate blocks from directories after they were
	allocated, it should be safe to perform pre-allocation and maintain
	compatibility with Linux.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-JOURNAL-UUID"
>3.1.38. s_journal_uuid</A
></H3
><P
>	16-byte value containing the uuid of the journal superblock.  See Ext3 
	Journaling for more information.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-JOURNAL-INUM"
>3.1.39. s_journal_inum</A
></H3
><P
>	32-bit inode number of the journal file.  See Ext3 Journaling for more 
	information.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-JOURNAL-DEV"
>3.1.40. s_journal_dev</A
></H3
><P
>	32-bit device number of the journal file.  See Ext3 Journaling for more 
	information.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-LAST-ORPHAN"
>3.1.41. s_last_orphan</A
></H3
><P
>	32-bit inode number, pointing to the first inode in the list of inodes
	to delete.  See Ext3 Journaling for more information.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-HASH-SEED"
>3.1.42. s_hash_seed</A
></H3
><P
>	An array of 4 32bit values containing the seeds used for the hash 
	algorithm for directory indexing.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-DEF-HASH-VERSION"
>3.1.43. s_def_hash_version</A
></H3
><P
>	An 8bit value containing the default hash version used for directory indexing.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-DEFAULT-MOUNT-OPTIONS"
>3.1.44. s_default_mount_options</A
></H3
><P
>	A 32bit value containing the default mount options for this file system. TODO: Add more information here!
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="S-FIRST-META-BG"
>3.1.45. s_first_meta_bg</A
></H3
><P
>	A 32bit value indicating the block group ID of the first meta block group.  TODO: Research if this is an Ext3-only extension.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BLOCK-GROUP-DESCRIPTOR-TABLE"
>3.2. Block Group Descriptor Table</A
></H2
><P
>	The block group descriptor table is an array of 
	<A
HREF="#BLOCK-GROUP-DESCRIPTOR-STRUCTURE"
>block group descriptor</A
>, 
	used to define parameters of all the 
  <A
HREF="#DEF-BLOCK-GROUPS"
>block groups</A
>. It provides the location
	of the inode bitmap	and inode table, block bitmap, number of free blocks and
	inodes, and some other useful information.
   </P
><P
>	The block group descriptor table starts on the first block following the
	superblock.  This would be the third block on a 1KiB block file system, or the
	second block for 2KiB and larger block file systems. Shadow copies of the
	block	group descriptor table are also stored with every copy of the 
	superblock.
   </P
><P
>	Depending on how many block groups are defined, this table can require
	multiple blocks of storage.  Always refer to the superblock in case of
	doubt.
   </P
><P
>	The layout of a block group descriptor is as follows:
   </P
><DIV
CLASS="TABLE"
><A
NAME="BLOCK-GROUP-DESCRIPTOR-STRUCTURE"
></A
><P
><B
>Table 3-12. Block Group Descriptor Structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>4</TD
><TD
><A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>4</TD
><TD
><A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
><A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
></TD
></TR
><TR
><TD
>12</TD
><TD
>2</TD
><TD
><A
HREF="#BG-FREE-BLOCKS-COUNT"
>bg_free_blocks_count</A
></TD
></TR
><TR
><TD
>14</TD
><TD
>2</TD
><TD
><A
HREF="#BG-FREE-INODES-COUNT"
>bg_free_inodes_count</A
></TD
></TR
><TR
><TD
>16</TD
><TD
>2</TD
><TD
><A
HREF="#BG-USED-DIRS-COUNT"
>bg_used_dirs_count</A
></TD
></TR
><TR
><TD
>18</TD
><TD
>2</TD
><TD
><A
HREF="#BG-PAD"
>bg_pad</A
></TD
></TR
><TR
><TD
>20</TD
><TD
>12</TD
><TD
><A
HREF="#BG-RESERVED"
>bg_reserved</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>	For each block group in the file system, such a <CODE
CLASS="STRUCTNAME"
>group_desc</CODE
> is
	created.  Each represent a single block group within the
	file system and the information within any one of them is pertinent
	only to the group it is describing.  Every block group descriptor table
	contains all the information about all the block groups.
   </P
><P
>	NOTE: All indicated <SPAN
CLASS="QUOTE"
>"block id"</SPAN
> are absolute.
   </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-BLOCK-BITMAP"
>3.2.1. bg_block_bitmap</A
></H3
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>"</SPAN
>
	for the group represented.
    </P
><P
>	The actual block bitmap is located within its own allocated blocks 
	starting at the block ID specified by this value.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-INODE-BITMAP"
>3.2.2. bg_inode_bitmap</A
></H3
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-BITMAP"
>inode bitmap</A
>"</SPAN
>
	for the group represented.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-INODE-TABLE"
>3.2.3. bg_inode_table</A
></H3
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-TABLE"
>inode table</A
>"</SPAN
>
	for the group represented.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-FREE-BLOCKS-COUNT"
>3.2.4. bg_free_blocks_count</A
></H3
><P
>	16bit value indicating the total number of free blocks for
	the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-FREE-INODES-COUNT"
>3.2.5. bg_free_inodes_count</A
></H3
><P
>	16bit value indicating the total number of free inodes for
	the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-USED-DIRS-COUNT"
>3.2.6. bg_used_dirs_count</A
></H3
><P
>	16bit value indicating the number of inodes allocated to
	directories for the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-PAD"
>3.2.7. bg_pad</A
></H3
><P
>	16bit value used for padding the structure on a 32bit boundary.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BG-RESERVED"
>3.2.8. bg_reserved</A
></H3
><P
>	12 bytes of reserved space for future revisions.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BLOCK-BITMAP"
>3.3. Block Bitmap</A
></H2
><P
>	On small file systems, the <SPAN
CLASS="QUOTE"
>"Block Bitmap"</SPAN
> is normally located
	at the first block, or second block if a superblock backup is present,
	of each block group. Its official location can be determined by reading the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
>"</SPAN
>
	in its associated <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>group descriptor</A
>.
   </P
><P
>	Each bit represent the current state of a block within that block group,
	where 1 means <SPAN
CLASS="QUOTE"
>"used"</SPAN
> and 0 <SPAN
CLASS="QUOTE"
>"free/available"</SPAN
>. The
	first block of this block group is represented by bit 0 of byte 0,
	the second by bit 1 of byte 0.  The 8th block is represented by bit 7
	(most significant bit) of byte 0 while the 9th block is represented by
	bit 0 (least significant bit) of byte 1.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INODE-BITMAP"
>3.4. Inode Bitmap</A
></H2
><P
>	The <SPAN
CLASS="QUOTE"
>"Inode Bitmap"</SPAN
> works in a similar way as the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BLOCK-BITMAP"
>Block Bitmap</A
>"</SPAN
>,
	difference being in each bit representing an inode in the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-TABLE"
>Inode Table</A
>"</SPAN
> rather
	than a block.
   </P
><P
>	There is one inode bitmap per group and its location may be
	determined by reading the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
>"</SPAN
>
	in its associated <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>group descriptor</A
>.
   </P
><P
>   	When the inode table is created, all the reserved inodes are marked
	as used.  In revision 0 this is the first 11 inodes.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INODE-TABLE"
>3.5. Inode Table</A
></H2
><P
>	The inode table is used to keep track of every directory,
	regular file, symbolic link, or special file; their
	location, size, type and access rights are all stored in inodes. There
	is no filename stored in the inode itself, names are contained in
	<A
HREF="#DIRECTORY"
>directory</A
> files only.
   </P
><P
>	There is one inode table per block group and it can be located by reading the
	<A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
>
	in its associated <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>group descriptor</A
>.
	There are <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
>
	inodes per table.
   </P
><P
>	Each inode contain the information about a single physical file on the
	system.  A file can be a directory, a socket, a buffer, character or
	block device, symbolic link or a regular file.  So an inode can be
	seen as a block of information related to an entity, describing its
	location on disk, its size and its owner.  An inode looks like this:
   </P
><DIV
CLASS="TABLE"
><A
NAME="INODE-STRUCTURE"
></A
><P
><B
>Table 3-13. Inode Structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>2</TD
><TD
><A
HREF="#I-MODE"
>i_mode</A
></TD
></TR
><TR
><TD
>2</TD
><TD
>2</TD
><TD
><A
HREF="#I-UID"
>i_uid</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>4</TD
><TD
><A
HREF="#I-SIZE"
>i_size</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
><A
HREF="#I-ATIME"
>i_atime</A
></TD
></TR
><TR
><TD
>12</TD
><TD
>4</TD
><TD
><A
HREF="#I-CTIME"
>i_ctime</A
></TD
></TR
><TR
><TD
>16</TD
><TD
>4</TD
><TD
><A
HREF="#I-MTIME"
>i_mtime</A
></TD
></TR
><TR
><TD
>20</TD
><TD
>4</TD
><TD
><A
HREF="#I-DTIME"
>i_dtime</A
></TD
></TR
><TR
><TD
>24</TD
><TD
>2</TD
><TD
><A
HREF="#I-GID"
>i_gid</A
></TD
></TR
><TR
><TD
>26</TD
><TD
>2</TD
><TD
><A
HREF="#I-LINKS-COUNT"
>i_links_count</A
></TD
></TR
><TR
><TD
>28</TD
><TD
>4</TD
><TD
><A
HREF="#I-BLOCKS"
>i_blocks</A
></TD
></TR
><TR
><TD
>32</TD
><TD
>4</TD
><TD
><A
HREF="#I-FLAGS"
>i_flags</A
></TD
></TR
><TR
><TD
>36</TD
><TD
>4</TD
><TD
><A
HREF="#I-OSD1"
>i_osd1</A
></TD
></TR
><TR
><TD
>40</TD
><TD
>15 x 4</TD
><TD
><A
HREF="#I-BLOCK"
>i_block</A
></TD
></TR
><TR
><TD
>100</TD
><TD
>4</TD
><TD
><A
HREF="#I-GENERATION"
>i_generation</A
></TD
></TR
><TR
><TD
>104</TD
><TD
>4</TD
><TD
><A
HREF="#I-FILE-ACL"
>i_file_acl</A
></TD
></TR
><TR
><TD
>108</TD
><TD
>4</TD
><TD
><A
HREF="#I-DIR-ACL"
>i_dir_acl</A
></TD
></TR
><TR
><TD
>112</TD
><TD
>4</TD
><TD
><A
HREF="#I-FADDR"
>i_faddr</A
></TD
></TR
><TR
><TD
>116</TD
><TD
>12</TD
><TD
><A
HREF="#I-OSD2"
>i_osd2</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>	The first few entries of the inode tables are reserved.  In revision
	0 there are 11 entries reserved while in revision 1
	(EXT2_DYNAMIC_REV) and later the number of reserved inodes entries is
	specified	in the <A
HREF="#S-FIRST-INO"
>s_first_ino</A
> of the 
	superblock structure.  Here's a listing of the known reserved inode 
	entries:
   </P
><DIV
CLASS="TABLE"
><A
NAME="RESERVED-INODES-VALUES"
></A
><P
><B
>Table 3-14. Defined Reserved Inodes</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_BAD_INO</TD
><TD
>1</TD
><TD
>bad blocks inode</TD
></TR
><TR
><TD
>EXT2_ROOT_INO</TD
><TD
>2</TD
><TD
>root directory inode</TD
></TR
><TR
><TD
>EXT2_ACL_IDX_INO</TD
><TD
>3</TD
><TD
>ACL index inode (deprecated?)</TD
></TR
><TR
><TD
>EXT2_ACL_DATA_INO</TD
><TD
>4</TD
><TD
>ACL data inode (deprecated?)</TD
></TR
><TR
><TD
>EXT2_BOOT_LOADER_INO</TD
><TD
>5</TD
><TD
>boot loader inode</TD
></TR
><TR
><TD
>EXT2_UNDEL_DIR_INO</TD
><TD
>6</TD
><TD
>undelete directory inode</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-MODE"
>3.5.1. i_mode</A
></H3
><P
>	16bit value used to indicate the format of the described file and the
	access rights.  Here are the possible values, which can be combined
	in various ways:
    </P
><DIV
CLASS="TABLE"
><A
NAME="AEN1288"
></A
><P
><B
>Table 3-15. Defined i_mode Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- file format --</TD
></TR
><TR
><TD
>EXT2_S_IFSOCK</TD
><TD
>0xC000</TD
><TD
>socket</TD
></TR
><TR
><TD
>EXT2_S_IFLNK</TD
><TD
>0xA000</TD
><TD
>symbolic link</TD
></TR
><TR
><TD
>EXT2_S_IFREG</TD
><TD
>0x8000</TD
><TD
>regular file</TD
></TR
><TR
><TD
>EXT2_S_IFBLK</TD
><TD
>0x6000</TD
><TD
>block device</TD
></TR
><TR
><TD
>EXT2_S_IFDIR</TD
><TD
>0x4000</TD
><TD
>directory</TD
></TR
><TR
><TD
>EXT2_S_IFCHR</TD
><TD
>0x2000</TD
><TD
>character device</TD
></TR
><TR
><TD
>EXT2_S_IFIFO</TD
><TD
>0x1000</TD
><TD
>fifo</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- process execution user/group override --</TD
></TR
><TR
><TD
>EXT2_S_ISUID</TD
><TD
>0x0800</TD
><TD
>Set process User ID</TD
></TR
><TR
><TD
>EXT2_S_ISGID</TD
><TD
>0x0400</TD
><TD
>Set process Group ID</TD
></TR
><TR
><TD
>EXT2_S_ISVTX</TD
><TD
>0x0200</TD
><TD
>sticky bit</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- access rights --</TD
></TR
><TR
><TD
>EXT2_S_IRUSR</TD
><TD
>0x0100</TD
><TD
>user read</TD
></TR
><TR
><TD
>EXT2_S_IWUSR</TD
><TD
>0x0080</TD
><TD
>user write</TD
></TR
><TR
><TD
>EXT2_S_IXUSR</TD
><TD
>0x0040</TD
><TD
>user execute</TD
></TR
><TR
><TD
>EXT2_S_IRGRP</TD
><TD
>0x0020</TD
><TD
>group read</TD
></TR
><TR
><TD
>EXT2_S_IWGRP</TD
><TD
>0x0010</TD
><TD
>group write</TD
></TR
><TR
><TD
>EXT2_S_IXGRP</TD
><TD
>0x0008</TD
><TD
>group execute</TD
></TR
><TR
><TD
>EXT2_S_IROTH</TD
><TD
>0x0004</TD
><TD
>others read</TD
></TR
><TR
><TD
>EXT2_S_IWOTH</TD
><TD
>0x0002</TD
><TD
>others write</TD
></TR
><TR
><TD
>EXT2_S_IXOTH</TD
><TD
>0x0001</TD
><TD
>others execute</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-UID"
>3.5.2. i_uid</A
></H3
><P
>	16bit user id associated with the file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-SIZE"
>3.5.3. i_size</A
></H3
><P
>	In revision 0, (signed) 32bit value indicating the size of the file in 
	bytes.  In revision 1 and later revisions, and only for regular files, this 
	represents the lower 32-bit of the file size; the upper 32-bit is located
	in the i_dir_acl.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-ATIME"
>3.5.4. i_atime</A
></H3
><P
>	32bit value representing the number of seconds since january 1st 1970
	of the last time this inode was accessed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-CTIME"
>3.5.5. i_ctime</A
></H3
><P
>	32bit value representing the number of seconds since january 1st 1970, of
	when the inode was created.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-MTIME"
>3.5.6. i_mtime</A
></H3
><P
>	32bit value representing the number of seconds since january 1st 1970,
	of the last time this inode was modified.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-DTIME"
>3.5.7. i_dtime</A
></H3
><P
>	32bit value representing the number of seconds since january 1st 1970, of
	when the inode was deleted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-GID"
>3.5.8. i_gid</A
></H3
><P
>	16bit value of the POSIX group having access to this file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-LINKS-COUNT"
>3.5.9. i_links_count</A
></H3
><P
>	16bit value indicating how many times this particular inode is linked 
	(referred to). Most files will have a link count of 1.  Files with hard 
	links pointing to them will have an additional count for each hard link.
    </P
><P
>	Symbolic links do not affect the link count of an inode. When the link count
	reaches 0 the inode and all its associated blocks are freed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-BLOCKS"
>3.5.10. i_blocks</A
></H3
><P
>	32-bit value representing the total number of 512-bytes blocks reserved to contain the
	data of this inode, regardless if these blocks are used or not.  The block
	numbers of these reserved blocks are contained in the 
	<A
HREF="#I-BLOCK"
>i_block</A
> array.
    </P
><P
>	Since this value represents 512-byte blocks and not file system blocks,
	this value should not be directly used as an index to the i_block array.
	Rather, the maximum index of the i_block array should be computed from
	i_blocks / ((1024&lt;&lt;s_log_block_size)/512), or once simplified, i_blocks/(2&lt;&lt;s_log_block_size).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-FLAGS"
>3.5.11. i_flags</A
></H3
><P
>	32bit value indicating how the ext2 implementation should behave when
	accessing the data for this inode.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DEFINED-I-FLAGS-VALUES"
></A
><P
><B
>Table 3-16. Defined i_flags Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><A
HREF="#EXT2-SECRM-FL"
>EXT2_SECRM_FL</A
></TD
><TD
>0x00000001</TD
><TD
>secure deletion</TD
></TR
><TR
><TD
><A
HREF="#EXT2-UNRM-FL"
>EXT2_UNRM_FL</A
></TD
><TD
>0x00000002</TD
><TD
>record for undelete</TD
></TR
><TR
><TD
><A
HREF="#EXT2-COMPR-FL"
>EXT2_COMPR_FL</A
></TD
><TD
>0x00000004</TD
><TD
>compressed file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-SYNC-FL"
>EXT2_SYNC_FL</A
></TD
><TD
>0x00000008</TD
><TD
>synchronous updates</TD
></TR
><TR
><TD
><A
HREF="#EXT2-IMMUTABLE-FL"
>EXT2_IMMUTABLE_FL</A
></TD
><TD
>0x00000010</TD
><TD
>immutable file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-APPEND-FL"
>EXT2_APPEND_FL</A
></TD
><TD
>0x00000020</TD
><TD
>append only</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NODUMP-FL"
>EXT2_NODUMP_FL</A
></TD
><TD
>0x00000040</TD
><TD
>do not dump/delete file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NOATIME-FL"
>EXT2_NOATIME_FL</A
></TD
><TD
>0x00000080</TD
><TD
>do not update .i_atime</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Reserved for compression usage --</TD
></TR
><TR
><TD
><A
HREF="#EXT2-DIRTY-FL"
>EXT2_DIRTY_FL</A
></TD
><TD
>0x00000100</TD
><TD
>Dirty (modified)</TD
></TR
><TR
><TD
><A
HREF="#EXT2-COMPRBLK-FL"
>EXT2_COMPRBLK_FL</A
></TD
><TD
>0x00000200</TD
><TD
>compressed blocks</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NOCOMPR-FL"
>EXT2_NOCOMPR_FL</A
></TD
><TD
>0x00000400</TD
><TD
>access raw compressed data</TD
></TR
><TR
><TD
><A
HREF="#EXT2-ECOMPR-FL"
>EXT2_ECOMPR_FL</A
></TD
><TD
>0x00000800</TD
><TD
>compression error</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- End of compression flags --</TD
></TR
><TR
><TD
><A
HREF="#EXT2-BTREE-FL"
>EXT2_BTREE_FL</A
></TD
><TD
>0x00001000</TD
><TD
>b-tree format directory</TD
></TR
><TR
><TD
><A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL</A
></TD
><TD
>0x00001000</TD
><TD
>hash indexed directory</TD
></TR
><TR
><TD
><A
HREF="#EXT2-IMAGIC-FL"
>EXT2_IMAGIC_FL</A
></TD
><TD
>0x00002000</TD
><TD
>AFS directory</TD
></TR
><TR
><TD
><A
HREF="#EXT3-JOURNAL-DATA-FL"
>EXT3_JOURNAL_DATA_FL</A
></TD
><TD
>0x00004000</TD
><TD
>journal file data</TD
></TR
><TR
><TD
><A
HREF="#EXT2-RESERVED-FL"
>EXT2_RESERVED_FL</A
></TD
><TD
>0x80000000</TD
><TD
>reserved for ext2 library</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-OSD1"
>3.5.12. i_osd1</A
></H3
><P
>        32bit OS dependant value.
    </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD1-HURD"
>3.5.12.1. Hurd</A
></H4
><P
>        32bit value labeled as <SPAN
CLASS="QUOTE"
>"translator"</SPAN
>.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD1-LINUX"
>3.5.12.2. Linux</A
></H4
><P
>        32bit value currently reserved.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD1-MASIX"
>3.5.12.3. Masix</A
></H4
><P
>        32bit value currently reserved.
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-BLOCK"
>3.5.13. i_block</A
></H3
><P
>	15 x 32bit block numbers pointing to the blocks containing the data for
	this inode. The first 12 blocks are direct blocks.  The 13th entry in this
	array is the block number of the first indirect block; which is a block
	containing an array of block ID containing the data.  Therefore, the 13th
	block of the file will be the first block ID contained in the indirect block.
	With a 1KiB block size, blocks 13 to 268 of the file data are contained
	in this indirect block.
     </P
><P
>	The 14th entry in this array is the block number of the first doubly-indirect
	block; which is a block containing an array of indirect block IDs, with each
	of those indirect blocks containing an array of blocks containing the data.  
	In a 1KiB block size, there would be 256 indirect blocks per doubly-indirect
	block, with 256 direct blocks per indirect block for a total of 65536 blocks 
	per doubly-indirect block.
     </P
><P
>	The 15th entry in this array is the block number of the triply-indirect 
	block; which is a	block containing an array of doubly-indrect block IDs,
	with each of those doubly-indrect block containing an array of indrect block,
	and each of those indirect block containing an array of direct block.  In a
	1KiB file system, this would be a total of 16777216 blocks per
	triply-indirect block.
     </P
><P
>	A value of 0 in this array effectively terminates it with no further block 
	being defined.	All the remaining entries of the array should still be set
	to 0.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-GENERATION"
>3.5.14. i_generation</A
></H3
><P
>        32bit value used to indicate the file version (used by NFS).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-FILE-ACL"
>3.5.15. i_file_acl</A
></H3
><P
>	32bit value indicating the block number containing the extended
	attributes. In revision 0 this value is always 0.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>      Patches and implementation status of ACL under Linux can generally be found at http://acl.bestbits.at/
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-DIR-ACL"
>3.5.16. i_dir_acl</A
></H3
><P
>	In revision 0 this 32bit value is always 0.  In revision 1, for regular
	files this 32bit value contains the high 32 bits of the 64bit file size.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Linux sets this value to 0 if the file is not a regular file (i.e. block
	devices, directories, etc).  In theory, this value could be set to point
	to a block containing extended attributes of the directory or special file.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-FADDR"
>3.5.17. i_faddr</A
></H3
><P
>	32bit value indicating the location of the file fragment.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux and GNU HURD, since fragments are unsupported this value is always 
	0.  In Ext4	this value is now marked as obsolete.
    </P
><P
>	In theory, this should contain the block number which hosts the
	actual fragment.  The fragment number and its size would be contained
	in the <A
HREF="#I-OSD2"
>i_osd2</A
> structure.
    </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="I-OSD2"
>3.5.18. Inode i_osd2 Structure</A
></H3
><P
>        96bit OS dependant structure.
    </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD2-HURD"
>3.5.18.1. Hurd</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="I-OSD2-HURD-STRUCTURE"
></A
><P
><B
>Table 3-17. Inode i_osd2 Structure: Hurd</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>1</TD
><TD
><A
HREF="#H-I-FRAG"
>h_i_frag</A
></TD
></TR
><TR
><TD
>1</TD
><TD
>1</TD
><TD
><A
HREF="#H-I-FSIZE"
>h_i_fsize</A
></TD
></TR
><TR
><TD
>2</TD
><TD
>2</TD
><TD
><A
HREF="#H-I-MODE-HIGH"
>h_i_mode_high</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>2</TD
><TD
><A
HREF="#H-I-UID-HIGH"
>h_i_uid_high</A
></TD
></TR
><TR
><TD
>6</TD
><TD
>2</TD
><TD
><A
HREF="#H-I-GID-HIGH"
>h_i_gid_high</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
><A
HREF="#H-I-AUTHOR"
>h_i_author</A
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-FRAG"
>3.5.18.1.1. h_i_frag</A
></H5
><P
>	8bit fragment number.  Always 0 GNU HURD since fragments are
	not supported. Obsolete with Ext4.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-FSIZE"
>3.5.18.1.2. h_i_fsize</A
></H5
><P
>	8bit fragment size.  Always 0 in GNU HURD since fragments are
	not supported.  Obsolete with Ext4.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-MODE-HIGH"
>3.5.18.1.3. h_i_mode_high</A
></H5
><P
>	High 16bit of the 32bit mode.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-UID-HIGH"
>3.5.18.1.4. h_i_uid_high</A
></H5
><P
>	High 16bit of <A
HREF="#I-UID"
>user id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-GID-HIGH"
>3.5.18.1.5. h_i_gid_high</A
></H5
><P
>	High 16bit of <A
HREF="#I-GID"
>group id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="H-I-AUTHOR"
>3.5.18.1.6. h_i_author</A
></H5
><P
>	32bit user id of the assigned file author. If this value is set to -1, the 
	POSIX <A
HREF="#I-UID"
>user id</A
> will be used.
      </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD2-LINUX"
>3.5.18.2. Linux</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="I-OSD2-LINUX-STRUCTURE"
></A
><P
><B
>Table 3-18. Inode i_osd2 Structure: Linux</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>1</TD
><TD
><A
HREF="#L-I-FRAG"
>l_i_frag</A
></TD
></TR
><TR
><TD
>1</TD
><TD
>1</TD
><TD
><A
HREF="#L-I-FSIZE"
>l_i_fsize</A
></TD
></TR
><TR
><TD
>2</TD
><TD
>2</TD
><TD
>reserved</TD
></TR
><TR
><TD
>4</TD
><TD
>2</TD
><TD
><A
HREF="#L-I-UID-HIGH"
>l_i_uid_high</A
></TD
></TR
><TR
><TD
>6</TD
><TD
>2</TD
><TD
><A
HREF="#L-I-GID-HIGH"
>l_i_gid_high</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="L-I-FRAG"
>3.5.18.2.1. l_i_frag</A
></H5
><P
>	8bit fragment number.
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	  Always 0 in Linux since fragments are not supported.
      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/important.gif"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	A new implementation of Ext2 should completely disregard this field
	if the <A
HREF="#I-FADDR"
>i_faddr</A
> value is 0; in Ext4 this
	field is combined with <A
HREF="#L-I-FSIZE"
>l_i_fsize</A
> to
	become the high 16bit of the 48bit blocks count for the inode data.
      </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="L-I-FSIZE"
>3.5.18.2.2. l_i_fsize</A
></H5
><P
>	8bit fragment size.
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	 Always 0 in Linux since fragments are not supported.
      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/important.gif"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	A new implementation of Ext2 should completely disregard this field
	if the <A
HREF="#I-FADDR"
>i_faddr</A
> value is 0; in Ext4 this
	field is combined with <A
HREF="#L-I-FRAG"
>l_i_frag</A
> to
	become the high 16bit of the 48bit blocks count for the inode data.
      </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="L-I-UID-HIGH"
>3.5.18.2.3. l_i_uid_high</A
></H5
><P
>	High 16bit of <A
HREF="#I-UID"
>user id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="L-I-GID-HIGH"
>3.5.18.2.4. l_i_gid_high</A
></H5
><P
>	High 16bit of <A
HREF="#I-GID"
>group id</A
>.
      </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="I-OSD2-MASIX"
>3.5.18.3. Masix</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="I-OSD2-MASIX-STRUCTURE"
></A
><P
><B
>Table 3-19. Inode i_osd2 Structure: Masix</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>1</TD
><TD
><A
HREF="#M-I-FRAG"
>m_i_frag</A
></TD
></TR
><TR
><TD
>1</TD
><TD
>1</TD
><TD
><A
HREF="#M-I-FSIZE"
>m_i_fsize</A
></TD
></TR
><TR
><TD
>2</TD
><TD
>10</TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="M-I-FRAG"
>3.5.18.3.1. m_i_frag</A
></H5
><P
>	8bit fragment number.  Always 0 in Masix as framgents are not
	supported.  Obsolete with Ext4.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="M-I-FSIZE"
>3.5.18.3.2. m_i_fsize</A
></H5
><P
>	8bit fragment size.  Always 0 in Masix as fragments are not
	supported.  Obsolete with Ext4.
      </P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1729"
>3.6. Locating an Inode</A
></H2
><P
>	Inodes are all numerically ordered.  The <SPAN
CLASS="QUOTE"
>"inode number"</SPAN
> is
	an index in the	<A
HREF="#INODE-TABLE"
>inode table</A
> to an
	<A
HREF="#INODE-STRUCTURE"
>inode</A
> structure.  The size of the
	inode table	is fixed at format time; it is built to hold a maximum
	number of	entries.  Due to the large amount of entries
	created, the table is quite big and thus, it is split equally among
	all the <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>block groups</A
>
	(see <A
HREF="#DISK-ORGANISATION"
>Chapter 3</A
>	for more information).
   </P
><P
>	The <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
> field in
	the <A
HREF="#SUPERBLOCK"
>superblock</A
> structure tells us how many
	inodes are defined per group.  Knowing that inode 1 is the first inode
	defined in the inode table, one can use the following formulaes:
   </P
><PRE
CLASS="PROGRAMLISTING"
>block group = (inode - 1) / s_inodes_per_group
   </PRE
><P
>	Once the block is identified, the local inode index for the local inode
	table can be identified using:
   </P
><PRE
CLASS="PROGRAMLISTING"
>local inode index = (inode - 1) % s_inodes_per_group
   </PRE
><P
>	Here are a couple of sample values that could be used to test
	your implementation:
   </P
><DIV
CLASS="TABLE"
><A
NAME="INODE-COMPUTATION-SAMPLE"
></A
><P
><B
>Table 3-20. Sample Inode Computations</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="30%"
TITLE="C2"><COL
WIDTH="30%"
TITLE="C3"><THEAD
><TR
><TH
>Inode Number</TH
><TH
>Block Group Number</TH
><TH
>Local Inode Index</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
>s_inodes_per_group = 1712</TD
></TR
><TR
><TD
>1</TD
><TD
>0</TD
><TD
>0</TD
></TR
><TR
><TD
>963</TD
><TD
>0</TD
><TD
>962</TD
></TR
><TR
><TD
>1712</TD
><TD
>0</TD
><TD
>1711</TD
></TR
><TR
><TD
>1713</TD
><TD
>1</TD
><TD
>0</TD
></TR
><TR
><TD
>3424</TD
><TD
>1</TD
><TD
>1711</TD
></TR
><TR
><TD
>3425</TD
><TD
>2</TD
><TD
>0</TD
></TR
></TBODY
></TABLE
></DIV
><P
>	As many of you are most likely already familiar with, an index of 0
	means the first entry.  The reason behind using 0 rather than 1 is that
	it can more easily be multiplied by the structure size to find the
	final byte offset of its location in memory or on disk.
   </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DIRECTORY"
></A
>Chapter 4. Directory Structure</H1
><P
>	Directories are used to hierarchically organize files.  Each directory
	can contain other directories, regular files and special files.
  </P
><P
>	Directories are stored as data block and referenced by an inode.  They
	can be identified by the file type
	<CODE
CLASS="CONSTANT"
>EXT2_S_IFDIR</CODE
> stored in the <A
HREF="#I-MODE"
>i_mode</A
>
	field of the <A
HREF="#INODE-STRUCTURE"
>inode</A
> structure.
  </P
><P
>	The second entry of the <A
HREF="#INODE-TABLE"
>Inode table</A
> contains
	the inode pointing to the data of the root directory; as defined by the
	<CODE
CLASS="CONSTANT"
>EXT2_ROOT_INO</CODE
> constant.
  </P
><P
>	In revision 0 directories could only be stored in a linked list.  Revision 1
	and later introduced indexed directories.  The indexed directory is backward
	compatible with the linked list directory; this is achieved by inserting
	empty directory entry records to skip over the hash indexes.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LINKED-DIRECTORIES"
>4.1. Linked List Directory</A
></H2
><P
>	A directory file is a linked list of 
	<A
HREF="#LINKED-DIRECTORY-ENTRY-STRUCTURE"
>directory entry</A
> 
	structures.  Each structure contains the name of the entry, the inode
	associated with the data of this entry, and the distance within the
	directory file to the next entry.
   </P
><P
>	In revision 0, the type of the entry (file, directory, special file, etc)
	has to be looked up in the inode of the file.  In revision 0.5 and later,
	the file type is also contained in the
	<A
HREF="#LINKED-DIRECTORY-ENTRY-STRUCTURE"
>directory entry</A
> structure.
   </P
><DIV
CLASS="TABLE"
><A
NAME="LINKED-DIRECTORY-ENTRY-STRUCTURE"
></A
><P
><B
>Table 4-1. Linked Directory Entry Structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>4</TD
><TD
><A
HREF="#IFDIR-INODE"
>inode</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>2</TD
><TD
><A
HREF="#IFDIR-REC-LEN"
>rec_len</A
></TD
></TR
><TR
><TD
>6</TD
><TD
>1</TD
><TD
><A
HREF="#IFDIR-NAME-LEN"
>name_len</A
><A
NAME="AEN1829"
HREF="#FTN.AEN1829"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
></TD
></TR
><TR
><TD
>7</TD
><TD
>1</TD
><TD
><A
HREF="#IFDIR-FILE-TYPE"
>file_type</A
><A
NAME="AEN1838"
HREF="#FTN.AEN1838"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
></TD
></TR
><TR
><TD
>8</TD
><TD
>0-255</TD
><TD
><A
HREF="#IFDIR-NAME"
>name</A
></TD
></TR
></TBODY
><TR
><TD
COLSPAN="3"
>Notes:<BR><A
NAME="FTN.AEN1829"
>a. </A
>	Revision 0 of Ext2 used a 16bit <CODE
CLASS="STRUCTFIELD"
>name_len</CODE
>;
	since most implementations restricted filenames to a maximum of 255
	characters this value was truncated to 8bit with the upper 8bit
	recycled as <A
HREF="#IFDIR-FILE-TYPE"
>file_type</A
>.
        <BR><A
NAME="FTN.AEN1838"
>b. </A
>	Not available in revision 0; this field was part of the 16bit
	<A
HREF="#IFDIR-NAME-LEN"
>name_len</A
> field.
        <BR></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IFDIR-INODE"
>4.1.1. inode</A
></H3
><P
>	32bit inode number of the file entry.  A value of 0 indicate that the entry
	is not used.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IFDIR-REC-LEN"
>4.1.2. rec_len</A
></H3
><P
>	16bit unsigned displacement to the next directory entry from the start of the
	current directory entry. This field must have a value at least equal to the
	length of the current record.
    </P
><P
>	The directory entries must be aligned on 4 bytes boundaries and there cannot
	be any directory entry spanning multiple data blocks.  If an entry cannot
	completely fit in one block, it must be pushed to the next data block and the
	rec_len of the previous entry properly adjusted.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Since this value cannot be negative, when a file is removed the previous
	record within the block has to be modified to point to the next valid record
	within the block or to the end of the block when no other directory entry is
	present.
     </P
><P
>	If the first entry within the block is removed, a blank record
	will be created and point to the next directory entry or to the end of the
	block.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IFDIR-NAME-LEN"
>4.1.3. name_len</A
></H3
><P
>	8bit unsigned value indicating how many bytes of character data are contained in the name.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	This value must never be larger than rec_len - 8.  If the directory entry
	name is updated and cannot fit in the existing directory entry, the entry may
	have to be relocated in a new directory entry of sufficient size and
	possibly stored in a new data block.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IFDIR-FILE-TYPE"
>4.1.4. file_type</A
></H3
><P
>	8bit unsigned value used to indicate file type.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In revision 0, this field was the upper 8-bit of the then 16-bit name_len.  
	Since all implementations still limited the file names to 255 characters this
	8-bit value was always 0.
     </P
><P
>	This value must match the inode type defined in the related inode entry.
     </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="IFDIR-FILE-TYPE-VALUES"
></A
><P
><B
>Table 4-2. Defined Inode File Type Values</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>EXT2_FT_UNKNOWN</TD
><TD
>0</TD
><TD
>Unknown File Type</TD
></TR
><TR
><TD
>EXT2_FT_REG_FILE</TD
><TD
>1</TD
><TD
>Regular File</TD
></TR
><TR
><TD
>EXT2_FT_DIR</TD
><TD
>2</TD
><TD
>Directory File</TD
></TR
><TR
><TD
>EXT2_FT_CHRDEV</TD
><TD
>3</TD
><TD
>Character Device</TD
></TR
><TR
><TD
>EXT2_FT_BLKDEV</TD
><TD
>4</TD
><TD
>Block Device</TD
></TR
><TR
><TD
>EXT2_FT_FIFO</TD
><TD
>5</TD
><TD
>Buffer File</TD
></TR
><TR
><TD
>EXT2_FT_SOCK</TD
><TD
>6</TD
><TD
>Socket File</TD
></TR
><TR
><TD
>EXT2_FT_SYMLINK</TD
><TD
>7</TD
><TD
>Symbolic Link</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IFDIR-NAME"
>4.1.5. name</A
></H3
><P
>	Name of the entry.  The ISO-Latin-1 character set is expected in most system.
	The name must be no longer than 255	bytes after encoding.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DIR-SAMPLE"
>4.1.6. Sample Directory</A
></H3
><P
>	Here's a sample of the home directory of one user on my system:
    </P
><PRE
CLASS="PROGRAMLISTING"
>$ ls -1a ~
.
..
.bash_profile
.bashrc
mbox
public_html
tmp
    </PRE
><P
>	For which the following data representation can be found on the storage
	device:
    </P
><DIV
CLASS="TABLE"
><A
NAME="SAMPLE-LINKED-DIRECTORY-DATA"
></A
><P
><B
>Table 4-3. Sample Linked Directory Data Layout, 4KiB blocks</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 0</TD
></TR
><TR
><TD
>0</TD
><TD
>4</TD
><TD
>inode number: 783362</TD
></TR
><TR
><TD
>4</TD
><TD
>2</TD
><TD
>record length: 12</TD
></TR
><TR
><TD
>6</TD
><TD
>1</TD
><TD
>name length: 1</TD
></TR
><TR
><TD
>7</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>8</TD
><TD
>1</TD
><TD
>name: .</TD
></TR
><TR
><TD
>9</TD
><TD
>3</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 1</TD
></TR
><TR
><TD
>12</TD
><TD
>4</TD
><TD
>inode number: 1109761</TD
></TR
><TR
><TD
>16</TD
><TD
>2</TD
><TD
>record length: 12</TD
></TR
><TR
><TD
>18</TD
><TD
>1</TD
><TD
>name length: 2</TD
></TR
><TR
><TD
>19</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>20</TD
><TD
>2</TD
><TD
>name: ..</TD
></TR
><TR
><TD
>22</TD
><TD
>2</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 2</TD
></TR
><TR
><TD
>24</TD
><TD
>4</TD
><TD
>inode number: 783364</TD
></TR
><TR
><TD
>28</TD
><TD
>2</TD
><TD
>record length: 24</TD
></TR
><TR
><TD
>30</TD
><TD
>1</TD
><TD
>name length: 13</TD
></TR
><TR
><TD
>31</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_REG_FILE</CODE
></TD
></TR
><TR
><TD
>32</TD
><TD
>13</TD
><TD
>name: .bash_profile</TD
></TR
><TR
><TD
>45</TD
><TD
>3</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 3</TD
></TR
><TR
><TD
>48</TD
><TD
>4</TD
><TD
>inode number: 783363</TD
></TR
><TR
><TD
>52</TD
><TD
>2</TD
><TD
>record length: 16</TD
></TR
><TR
><TD
>54</TD
><TD
>1</TD
><TD
>name length: 7</TD
></TR
><TR
><TD
>55</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_REG_FILE</CODE
></TD
></TR
><TR
><TD
>56</TD
><TD
>7</TD
><TD
>name: .bashrc</TD
></TR
><TR
><TD
>63</TD
><TD
>1</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 4</TD
></TR
><TR
><TD
>64</TD
><TD
>4</TD
><TD
>inode number: 783377</TD
></TR
><TR
><TD
>68</TD
><TD
>2</TD
><TD
>record length: 12</TD
></TR
><TR
><TD
>70</TD
><TD
>1</TD
><TD
>name length: 4</TD
></TR
><TR
><TD
>71</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_REG_FILE</CODE
></TD
></TR
><TR
><TD
>72</TD
><TD
>4</TD
><TD
>name: mbox</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 5</TD
></TR
><TR
><TD
>76</TD
><TD
>4</TD
><TD
>inode number: 783545</TD
></TR
><TR
><TD
>80</TD
><TD
>2</TD
><TD
>record length: 20</TD
></TR
><TR
><TD
>82</TD
><TD
>1</TD
><TD
>name length: 11</TD
></TR
><TR
><TD
>83</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>84</TD
><TD
>11</TD
><TD
>name: public_html</TD
></TR
><TR
><TD
>95</TD
><TD
>1</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 6</TD
></TR
><TR
><TD
>96</TD
><TD
>4</TD
><TD
>inode number: 669354</TD
></TR
><TR
><TD
>100</TD
><TD
>2</TD
><TD
>record length: 12</TD
></TR
><TR
><TD
>102</TD
><TD
>1</TD
><TD
>name length: 3</TD
></TR
><TR
><TD
>103</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>104</TD
><TD
>3</TD
><TD
>name: tmp</TD
></TR
><TR
><TD
>107</TD
><TD
>1</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>Directory Entry 7</TD
></TR
><TR
><TD
>108</TD
><TD
>4</TD
><TD
>inode number: 0</TD
></TR
><TR
><TD
>112</TD
><TD
>2</TD
><TD
>record length: 3988</TD
></TR
><TR
><TD
>114</TD
><TD
>1</TD
><TD
>name length: 0</TD
></TR
><TR
><TD
>115</TD
><TD
>1</TD
><TD
>file type: <CODE
CLASS="CONSTANT"
>EXT2_FT_UNKNOWN</CODE
></TD
></TR
><TR
><TD
>116</TD
><TD
>0</TD
><TD
>name:</TD
></TR
><TR
><TD
>116</TD
><TD
>3980</TD
><TD
>padding</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INDEXED-DIRECTORY"
>4.2. Indexed Directory Format</A
></H2
><P
>	Using the standard linked list directory format can become very slow
	once the number of files starts growing.  To improve performances in
	such a system, a hashed index is used, which allow to quickly
	locate the particular file searched.
   </P
><P
>	Bit <A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL</A
> in the
	<A
HREF="#I-FLAGS"
>i_flags</A
> of the directory inode
	is set if the indexed directory format is used.
   </P
><P
>	In order to maintain backward compatibility with older implementations,
	the indexed directory also maintains a linked directory format side-by-side.
	In case there's any discrepency between the indexed and linked directories,
	the linked directory is preferred.
   </P
><P
>	This backward compatibility is achieved by placing a fake directory entries
	at the beginning of block 0 of the indexed directory data blocks.  These
	fake entries are part of the <A
HREF="#DX-ROOT-STRUCTURE"
>dx_root</A
>
	structure and host the linked directory information for the "." and ".."
	folder entries.
   </P
><P
>	Immediately following the <A
HREF="#DX-ROOT"
>Section 4.2.1</A
> structure is an array
	of <A
HREF="#DX-ENTRY"
>Section 4.2.2</A
> up to the end of the data block or until
	all files have been indexed.
   </P
><P
>	When the number of files to be indexed exceeds the number of <A
HREF="#DX-ENTRY"
>Section 4.2.2</A
>
	that can fit in a block (<A
HREF="#DX-ENTRY-COUNTLIMIT-LIMIT"
>Section 4.2.2.3</A
>), a level
	of indirect indexes is created.  An indirect index is another data block allocated
	to the directory inode that contains directory entries.
   </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DX-ROOT"
>4.2.1. Indexed Directory Root</A
></H3
><DIV
CLASS="TABLE"
><A
NAME="DX-ROOT-STRUCTURE"
></A
><P
><B
>Table 4-4. Indexed Directory Root Structure</B
></P
><TABLE
BORDER="1"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Linked Directory Entry: . --</TD
></TR
><TR
><TD
>0</TD
><TD
>4</TD
><TD
>inode: this directory</TD
></TR
><TR
><TD
>4</TD
><TD
>2</TD
><TD
>rec_len: 12</TD
></TR
><TR
><TD
>6</TD
><TD
>1</TD
><TD
>name_len: 1</TD
></TR
><TR
><TD
>7</TD
><TD
>1</TD
><TD
>file_type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>8</TD
><TD
>1</TD
><TD
>name: .</TD
></TR
><TR
><TD
>9</TD
><TD
>3</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Linked Directory Entry: .. --</TD
></TR
><TR
><TD
>12</TD
><TD
>4</TD
><TD
>inode: parent directory</TD
></TR
><TR
><TD
>16</TD
><TD
>2</TD
><TD
>rec_len: (blocksize - this entry's length(12))</TD
></TR
><TR
><TD
>18</TD
><TD
>1</TD
><TD
>name_len: 2</TD
></TR
><TR
><TD
>19</TD
><TD
>1</TD
><TD
>file_type: <CODE
CLASS="CONSTANT"
>EXT2_FT_DIR</CODE
>=2</TD
></TR
><TR
><TD
>20</TD
><TD
>2</TD
><TD
>name: ..</TD
></TR
><TR
><TD
>22</TD
><TD
>2</TD
><TD
>padding</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
>-- Indexed Directory Root Information Structure --</TD
></TR
><TR
><TD
>24</TD
><TD
>4</TD
><TD
>reserved, zero</TD
></TR
><TR
><TD
>28</TD
><TD
>1</TD
><TD
><A
HREF="#DX-HASH-VERSION"
>hash_version</A
></TD
></TR
><TR
><TD
>29</TD
><TD
>1</TD
><TD
><A
HREF="#DX-INFO-LENGTH"
>info_length</A
></TD
></TR
><TR
><TD
>30</TD
><TD
>1</TD
><TD
><A
HREF="#DX-INDIRECT-LEVELS"
>indirect_levels</A
></TD
></TR
><TR
><TD
>31</TD
><TD
>1</TD
><TD
>reserved - unused flags</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-HASH-VERSION"
>4.2.1.1. hash_version</A
></H4
><P
>	8bit value representing the hash version used in this indexed directory.
     </P
><DIV
CLASS="TABLE"
><A
NAME="DEFINED-DX-HASH-VERSION-VALUES"
></A
><P
><B
>Table 4-5. Defined Indexed Directory Hash Versions</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="40%"
TITLE="C3"><THEAD
><TR
><TH
>Constant Name</TH
><TH
>Value</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DX_HASH_LEGACY</TD
><TD
>0</TD
><TD
>TODO: link to section</TD
></TR
><TR
><TD
>DX_HASH_HALF_MD4</TD
><TD
>1</TD
><TD
>TODO: link to section</TD
></TR
><TR
><TD
>DX_HASH_TEA</TD
><TD
>2</TD
><TD
>TODO: link to section</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-INFO-LENGTH"
>4.2.1.2. info_length</A
></H4
><P
>	8bit length of the indexed directory information structure (dx_root); 
	currently equal to 8.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-INDIRECT-LEVELS"
>4.2.1.3. indirect_levels</A
></H4
><P
>	8bit value indicating how many indirect levels of indexing are present in
	this hash.
     </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux, as of 2.6.28, the maximum indirect levels value supported is 1.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DX-ENTRY"
>4.2.2. Indexed Directory Entry</A
></H3
><P
>	The indexed directory entries are used to quickly lookup the inode number
	associated with the hash of a filename.  These entries are located immediately
	following the fake linked directory entry of the directory data blocks, or
	immediately following the <A
HREF="#DX-ROOT"
>Section 4.2.1</A
>.
    </P
><P
>	The first indexed directory entry, rather than containing an actual hash and
	block	number, contains the maximum number of indexed directory entries that
	can fit in the block and the actual number of indexed directory entries 
	stored in the block.	The format of this special entry is detailed in
	<A
HREF="#DX-ENTRY-COUNTLIMIT"
>Table 4-7</A
>.
    </P
><P
>	The other directory entries are sorted by hash value starting from the 
	smallest to the largest numerical value.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DX-ENTRY-STRUCTURE"
></A
><P
><B
>Table 4-6. Indexed Directory Entry Structure (dx_entry)</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>4</TD
><TD
><A
HREF="#DX-ENTRY-HASH"
>hash</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>4</TD
><TD
><A
HREF="#DX-ENTRY-BLOCK"
>block</A
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="DX-ENTRY-COUNTLIMIT"
></A
><P
><B
>Table 4-7. Indexed Directory Entry Count and Limit Structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytes)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>2</TD
><TD
><A
HREF="#DX-ENTRY-COUNTLIMIT-LIMIT"
>limit</A
></TD
></TR
><TR
><TD
>2</TD
><TD
>2</TD
><TD
><A
HREF="#DX-ENTRY-COUNTLIMIT-COUNT"
>count</A
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-ENTRY-HASH"
>4.2.2.1. hash</A
></H4
><P
>	32bit hash of the filename represented by this entry.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-ENTRY-BLOCK"
>4.2.2.2. block</A
></H4
><P
>	32bit block index of the directory inode data block containing the (linked) directory entry for the filename.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-ENTRY-COUNTLIMIT-LIMIT"
>4.2.2.3. limit</A
></H4
><P
>	16bit value representing the total number of indexed directory entries that
	fit within the block, after removing the other structures, but including
	the count/limit entry.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DX-ENTRY-COUNTLIMIT-COUNT"
>4.2.2.4. count</A
></H4
><P
>	16bit value representing the total number of indexed directory entries
	present in the block. TODO: Research if this value includes the count/limit entry.
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-LOOKUP-ALGORITHM"
>4.2.3. Lookup Algorithm</A
></H3
><P
>	Lookup is straightforword:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Compute a hash of the name
- Read the index root
- Use binary search (linear in the current code) to find the
  first index or leaf block that could contain the target hash
  (in tree order)
- Repeat the above until the lowest tree level is reached
- Read the leaf directory entry block and do a normal Ext2
  directory block search in it.
- If the name is found, return its directory entry and buffer
- Otherwise, if the collision bit of the next directory entry is
  set, continue searching in the successor block
    </PRE
><P
>	Normally, two logical blocks of the file will need to be accessed, and
	one or two metadata index blocks.  The effect of the metadata index
	blocks can largely be ignored in terms of disk access time since these
	blocks are unlikely to be evicted from cache.  There is some small CPU
	cost that can be addressed by moving the whole directory into the page
	cache.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-INSERT-ALGORITHM"
>4.2.4. Insert Algorithm</A
></H3
><P
>	Insertion of new entries into the directory is considerably more
	complex than lookup, due to the need to split leaf blocks when they
	become full, and to satisfy the conditions that allow hash key
	collisions to be handled reliably and efficiently.  I'll just summarize
	here:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Probe the index as for lookup
- If the target leaf block is full, split it and note the block
  that will receive the new entry
- Insert the new entry in the leaf block using the normal Ext2
  directory entry insertion code.
    </PRE
><P
>	The details of splitting and hash collision handling are somewhat
	messy, but I will be happy to dwell on them at length if anyone is
	interested.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-SPLITTING"
>4.2.5. Splitting</A
></H3
><P
>	In brief, when a leaf node fills up and we want to put a new entry into
	it the leaf has to be split, and its share of the hash space has to
	be partitioned.  The most straightforward way to do this is to sort the
	entrys by hash value and split somewhere in the middle of the sorted
	list.  This operation is log(number_of_entries_in_leaf) and is not a
	great cost so long as an efficient sorter is used.  I used Combsort
	for this, although Quicksort would have been just as good in this
	case since average case performance is more important than worst case. 
    </P
><P
>	An alternative approach would be just to guess a median value for the
	hash key, and the partition could be done in linear time, but the
	resulting poorer partitioning of hash key space outweighs the small
	advantage of the linear partition algorithm.  In any event, the number
	of entries needing sorting is bounded by the number that fit in a leaf.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-KEY-COLLISIONS"
>4.2.6. Key Collisions</A
></H3
><P
>	Some complexity is introduced by the need to handle sequences of hash
	key collisions.  It is desireable to avoid splitting such sequences
	between blocks, so the split point of a block is adjusted with this in
	mind.  But the possibility still remains that if the block fills up
	with identically-hashed entries, the sequence may still have to be
	split.  This situation is flagged by placing a 1 in the low bit of the
	index entry that points at the sucessor block, which is naturally
	interpreted by the index probe as an intermediate value without any
	special coding.  Thus, handling the collision problem imposes no real
	processing overhead, just come extra code and a slight reduction in the
	hash key space.  The hash key space remains  sufficient for any
	conceivable number of directory entries, up into the billions.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-HASH-FUNCTION"
>4.2.7. Hash Function</A
></H3
><P
>	The exact properties of the hash function critically affect the
	performance of this indexing strategy, as I learned by trying a number
	of poor hash functions, at times intentionally.  A poor hash function
	will result in many collisions or poor partitioning of the hash space. 
	To illustrate why the latter is a problem, consider what happens when a
	block is split such that it covers just a few distinct hash values. 
	The probability of later index entries hashing into the same, small
	hash space is very small.  In practice, once a block is split, if its
	hash space is too small it tends to stay half full forever, an effect I
	observed in practice.
    </P
><P
>	After some experimentation I came up with a hash function that gives
	reasonably good dispersal of hash keys across the entire 31 bit key
	space.  This improved the average fullness of leaf blocks considerably,
	getting much closer to the theoretical average of 3/4 full.
    </P
><P
>	But the current hash function is just a place holder, waiting for
	an better version based on some solid theory.  I currently favor the
	idea of using crc32 as the default hash function, but I welcome
	suggestions.
    </P
><P
>	Inevitably, no matter how good a hash function I come up with, somebody
	will come up with a better one later.  For this reason the design
	allows for additional hash functiones to be added, with backward
	compatibility.  This is accomplished simply, by including a hash
	function number in the index root.  If a new, improved hash function is
	added, all the previous versions remain available, and previously
	created indexes remain readable.
    </P
><P
>	Of course, the best strategy is to have a good hash function right from
	the beginning.  The initial, quick hack has produced results that
	certainly have not been disappointing.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONTRIB-PERFORMANCE"
>4.2.8. Performance</A
></H3
><P
>	OK, if you have read this far then this is no doubt the part you've
	been waiting for.  In short, the performance improvement over normal
	Ext2 has been stunning.  With very small directories performance is
	similar to standard Ext2, but as directory size increases standard
	Ext2 quickly blows up quadratically, while htree-enhanced Ext2
	continues to scale linearly.
    </P
><P
>	Uli Luckas ran benchmarks for file creation in various sizes of
	directories ranging from 10,000 to 90,000 files.  The results are
	pleasing: total file creation time stays very close to linear, versus
	quadratic increase with normal Ext2.
    </P
><P
>	Time to create:
    </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN2384"
></A
><P
><B
>Figure 4-1. Performance of Indexed Directories</B
></P
><PRE
CLASS="PROGRAMLISTING"
>		Indexed		Normal
		=======		======
10000 Files:	0m1.350s	0m23.670s
20000 Files:	0m2.720s	1m20.470s
30000 Files:	0m4.330s	3m9.320s
40000 Files:	0m5.890s	5m48.750s
50000 Files:	0m7.040s	9m31.270s
60000 Files:	0m8.610s	13m52.250s
70000 Files:	0m9.980s	19m24.070s
80000 Files:	0m12.060s	25m36.730s
90000 Files:	0m13.400s	33m18.550s
    </PRE
></DIV
><P
>	A graph is posted at: http://www.innominate.org/~phillips/htree/performance.png
    </P
><P
>	All of these tests are CPU-bound, which may come as a surprise.  The
	directories fit easily in cache, and the limiting factor in the case of
	standard Ext2 is the looking up of directory blocks in buffer cache,
	and the low level scan of directory entries.  In the case of htree
	indexing there are a number of costs to be considered, all of them
	pretty well bounded.  Notwithstanding, there are a few obvious
	optimizations to be done:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Use binary search instead of linear search in the interior index
  nodes.

- If there is only one leaf block in a directory, bypass the index
  probe, go straight to the block.

- Map the directory into the page cache instead of the buffer cache.
    </PRE
><P
>	Each of these optimizations will produce a noticeable improvement in
	performance, but naturally it will never be anything like the big jump
	going from N**2 to Log512(N), ~= N.  In time the optimizations will be
	applied and we can expect to see another doubling or so in performance.
    </P
><P
>	There will be a very slight performance hit when the directory gets big
	enough to need a second level.  Because of caching this will be very
	small.  Traversing the directories metadata index blocks will be a
	bigger cost, and once again, this cost can be reduced by moving the
	directory blocks into the page cache.
    </P
><P
>	Typically, we will traverse 3 blocks to read or write a directory
	entry, and that number increases to 4-5 with really huge directories. 
	But this is really nothing compared to normal Ext2, which traverses
	several hundred blocks in the same situation.
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN2393"
></A
>Chapter 5. File Attributes</H1
><P
>	Most of the file (also directory, symlink, device...) attributes are
	located in the <A
HREF="#INODE-TABLE"
>inode</A
> associated with the file.
	Some other attributes are only available as extended attributes.
  </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2397"
>5.1. Standard Attributes</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2399"
>5.1.1. SUID, SGID and -rwxrwxrwx</A
></H3
><P
>	There isn't much to say about those, they are located with the SGID and SUID bits in
	<A
HREF="#I-MODE"
>ext2_inode.i_mode</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2403"
>5.1.2. File Size</A
></H3
><P
>	The size of a file can be determined by looking at the
	<A
HREF="#I-SIZE"
>ext2_inode.i_size</A
> field.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2407"
>5.1.3. Owner and Group</A
></H3
><P
>	Under most implementations, the owner and group are 16bit values, but on
	some recent Linux and Hurd implementations the owner and group id are
	32bit.  When 16bit values are used, only the <SPAN
CLASS="QUOTE"
>"low"</SPAN
> part should
	be used as valid, while when using 32bit value, both the <SPAN
CLASS="QUOTE"
>"low"</SPAN
>
	and <SPAN
CLASS="QUOTE"
>"high"</SPAN
> part should be used, the high part being shifted left
	16 places then added to the low part.
    </P
><P
>	The low part of owner and group are located in
	<A
HREF="#I-UID"
>ext2_inode.i_uid</A
> and
	<A
HREF="#I-GID"
>ext2_inode.i_gid</A
> respectively.
    </P
><P
>	The high part of owner and group are located in
	<A
HREF="#H-I-UID-HIGH"
>ext2_inode.osd2.hurd.h_i_uid_high</A
> and
	<A
HREF="#L-I-GID-HIGH"
>ext2_inode.osd2.hurd.h_i_gid_high</A
>,
	respectively, for Hurd and located in
	<A
HREF="#L-I-UID-HIGH"
>ext2_inode.osd2.linux.l_i_uid_high</A
> and
	<A
HREF="#L-I-GID-HIGH"
>ext2_inode.osd2.linux.l_i_gid_high</A
>,
	respectively, for Linux.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONTRIB-EXTENDED-ATTRIBUTES"
>5.2. Extended Attributes</A
></H2
><P
>	Extended attributes are name:value pairs associated  permanently  with
	files and directories, similar to the environment  strings  associated
	with a process.  An attribute may be defined or undefined.  If  it  is
	defined, its value  may	be empty or non-empty.
   </P
><P
>	Extended attributes are extensions to the normal attributes which  are
	associated with all inodes in the  system.  They  are  often  used  to
	provide additional  functionality  to  a  filesystem  -  for  example, 
	additional security features such as Access Control Lists  (ACLs)  may
	be implemented using extended attributes.
   </P
><P
>	Extended attributes are accessed as atomic objects. Reading  retrieves
	the whole value of an attribute and stores it  in  a  buffer.  Writing
	replaces any previous value with the new value.
   </P
><P
>	Extended attributes are stored on disk blocks allocated outside of
	any inode. The <A
HREF="#I-FILE-ACL"
>i_file_acl</A
> field (for
	regular files) or the <A
HREF="#I-DIR-ACL"
>i_dir_acl</A
> field
	(for directories) fields contain the block number of the allocated data
	block used to store the	extended attributes.
   </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Inodes which have all identical extended attributes may share the same
	extended attribute block.
   </P
></TD
></TR
></TABLE
></DIV
><P
>	The attribute values are on the  same block  as their  attribute entry
	descriptions, aligned to the end of the  attribute block.  This allows
	for additional attributes to be added more easily. The  size  of  entry
	headers  varies with  the length  of the	attribute name.
   </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXTENDED-ATTRIBUTE-LAYOUT"
>5.2.1. Extended Attribute Block Layout</A
></H3
><P
>	The block header is followed by multiple entry descriptors. These entry
	descriptors are variable in size, and aligned to <CODE
CLASS="CONSTANT"
>EXT2_XATTR_PAD</CODE
>
	(4) byte boundaries. The entry descriptors are sorted by attribute name,
	so that two extended attribute blocks can be compared efficiently.
    </P
><P
>	Attribute values are aligned to the end of the block, stored in
	no specific order. They are also padded to <CODE
CLASS="CONSTANT"
>EXT2_XATTR_PAD</CODE
> (4)
	byte boundaries. No additional gaps are left between them.
    </P
><DIV
CLASS="TABLE"
><A
NAME="EXTENDED-ATTRIBUTE-BLOCK-LAYOUT"
></A
><P
><B
>Table 5-1. Extended Attribute Block Layout</B
></P
><TABLE
BORDER="1"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"
TITLE="C1"><COL
WIDTH="5%"
ALIGN="CENTER"
TITLE="C2"><COL
WIDTH="55%"
TITLE="C3"><TBODY
><TR
><TD
>Attribute Block Header</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>Attribute Entry 1</TD
><TD
>|</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>Attribute Entry 2</TD
><TD
>|</TD
><TD
>growing downwards</TD
></TR
><TR
><TD
>Attribute Entry 3</TD
><TD
>V</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>4 null bytes</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>unused space...</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>Attribute Value 1</TD
><TD
>^</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>Attribute Value 3</TD
><TD
>|</TD
><TD
>growing upwards</TD
></TR
><TR
><TD
>Attribute Value 2</TD
><TD
>|</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ATTRIBUTE-BLOCK-HEADER"
>5.2.2. Extended Attribute Block Header</A
></H3
><DIV
CLASS="TABLE"
><A
NAME="ATTRIBUTE-BLOCK-HEADER-STRUCTURE"
></A
><P
><B
>Table 5-2. ext2_xattr_header structure</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="20%"
TITLE="C1"><COL
WIDTH="20%"
TITLE="C2"><COL
WIDTH="60%"
TITLE="C3"><THEAD
><TR
><TH
>Offset (bytes)</TH
><TH
>Size (bytse)</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0</TD
><TD
>4</TD
><TD
><A
HREF="#XATTR-H-MAGIC"
>h_magic</A
></TD
></TR
><TR
><TD
>4</TD
><TD
>4</TD
><TD
><A
HREF="#XATTR-H-REFCOUNT"
>h_refcount</A
></TD
></TR
><TR
><TD
>8</TD
><TD
>4</TD
><TD
><A
HREF="#XATTR-H-BLOCKS"
>h_blocks</A
></TD
></TR
><TR
><TD
>12</TD
><TD
>4</TD
><TD
><A
HREF="#XATTR-H-HASH"
>h_hash</A
></TD
></TR
><TR
><TD
>16</TD
><TD
>16</TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-H-MAGIC"
>5.2.2.1. h_magic</A
></H4
><P
>	32bit magic number of identification, <CODE
CLASS="CONSTANT"
>EXT2_XATTR_MAGIC</CODE
> = 0xEA020000.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-H-REFCOUNT"
>5.2.2.2. h_refcount</A
></H4
><P
>	32bit value used as reference count.  This value is incremented everytime
	a link is created to this attribute block and decremented when a link is
	destroyed.  Whenever this value reaches 0 the attribute block can be freed.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-H-BLOCKS"
>5.2.2.3. h_blocks</A
></H4
><P
>	32bit value indicating how many blocks are currently used by the
	extended attributes.
     </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	In Linux a value of h_blocks higher than 1 is considered invalid.  This
	effectively restrict the amount of extended attributes to what can be
	fit in a single block.
     </P
><P
>	There does not seem to be any support for extended attributes in Ext2 under
	GNU HURD.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-H-HASH"
>5.2.2.4. h_hash</A
></H4
><P
>	32bit hash value of all attribute entry header hashes.
     </P
><DIV
CLASS="PROCEDURE"
><P
><B
><A
NAME="XATTR-H-HASH-PROCEDURE"
></A
>Procedure to compute Extended Attribute Header Hash</B
></P
><OL
TYPE="1"
><LI
CLASS="STEP"
><P
>Initialize the 32bit hash to 0</P
></LI
><LI
CLASS="STEP"
><A
NAME="XATTR-H-HASH-PROCEDURE-LOOP"
></A
><P
>Check if there are any extended 
	attribute entry to process, if not we are done.</P
></LI
><LI
CLASS="STEP"
><P
>Do a cyclic bit shift of 16 bits to the left of the
	32bits hash value, effectively swapping the upper and lower 16bits of the hash</P
></LI
><LI
CLASS="STEP"
><P
>Perform a bitwise OR between the extended attribute entry
	<A
HREF="#XATTR-E-HASH"
>hash</A
> and the header hash being computed.</P
></LI
><LI
CLASS="STEP"
><P
>Go back to <A
HREF="#XATTR-H-HASH-PROCEDURE-LOOP"
>step 2</A
>&#62;.</P
></LI
></OL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2540"
>5.2.3. Attribute Entry Header</A
></H3
><DIV
CLASS="FIGURE"
><A
NAME="AEN2542"
></A
><P
><B
>Figure 5-1. ext2_xattr_header structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       1 <A
HREF="#XATTR-E-NAME-LEN"
>e_name_len</A
>
      1       1 <A
HREF="#XATTR-E-NAME-INDEX"
>e_name_index</A
>
      2       2 <A
HREF="#XATTR-E-VALUE-OFFS"
>e_value_offs</A
>
      4       4 <A
HREF="#XATTR-E-VALUE-BLOCK"
>e_value_block</A
>
      8       4 <A
HREF="#XATTR-E-VALUE-SIZE"
>e_value_size</A
>
     12       4 <A
HREF="#XATTR-E-HASH"
>e_hash</A
>
     16     ... <A
HREF="#XATTR-E-NAME"
>e_name</A
>
    </PRE
></DIV
><P
>	The total size of an attribute entry is always rounded to the
	next 4-bytes boundary.
    </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-NAME-LEN"
>5.2.3.1. e_name_len</A
></H4
><P
>	8bit unsigned value indicating the length of the name.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-NAME-INDEX"
>5.2.3.2. e_name_index</A
></H4
><P
>	8bit unsigned value used as attribute name index.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-OFFS"
>5.2.3.3. e_value_offs</A
></H4
><P
>	16bit unsigned offset to the value within the value block.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-BLOCK"
>5.2.3.4. e_value_block</A
></H4
><P
>	32bit id of the block holding the value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-SIZE"
>5.2.3.5. e_value_size</A
></H4
><P
>	32bit unsigned value indicating the size of the attribute value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-HASH"
>5.2.3.6. e_hash</A
></H4
><P
>	32bit hash of attribute name and value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XATTR-E-NAME"
>5.2.3.7. e_name</A
></H4
><P
>	Attribute name.
     </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BEHAVIOUR-FLAGS"
>5.3. Behaviour Control Flags</A
></H2
><P
>	The <A
HREF="#I-FLAGS"
>i_flags</A
> value in the
	<A
HREF="#INODE-STRUCTURE"
>inode</A
> structure allows to  specify how the
	file system should behave in regard to the file.  The following bits
	are currently defined:
   </P
><DIV
CLASS="TABLE"
><A
NAME="AEN2579"
></A
><P
><B
>Table 5-3. Behaviour Control Flags</B
></P
><TABLE
BORDER="0"
FRAME="void"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="40%"><COL
WIDTH="20%"><COL
WIDTH="40%"><TBODY
><TR
><TD
><A
HREF="#EXT2-SECRM-FL"
>EXT2_SECRM_FL</A
></TD
><TD
>0x00000001</TD
><TD
>secure deletion</TD
></TR
><TR
><TD
><A
HREF="#EXT2-UNRM-FL"
>EXT2_UNRM_FL</A
></TD
><TD
>0x00000002</TD
><TD
>record for undelete</TD
></TR
><TR
><TD
><A
HREF="#EXT2-COMPR-FL"
>EXT2_COMPR_FL</A
></TD
><TD
>0x00000004</TD
><TD
>compressed file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-SYNC-FL"
>EXT2_SYNC_FL</A
></TD
><TD
>0x00000008</TD
><TD
>synchronous updates</TD
></TR
><TR
><TD
><A
HREF="#EXT2-IMMUTABLE-FL"
>EXT2_IMMUTABLE_FL</A
></TD
><TD
>0x00000010</TD
><TD
>immutable file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-APPEND-FL"
>EXT2_APPEND_FL</A
></TD
><TD
>0x00000020</TD
><TD
>append only</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NODUMP-FL"
>EXT2_NODUMP_FL</A
></TD
><TD
>0x00000040</TD
><TD
>do not dump/delete file</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NOATIME-FL"
>EXT2_NOATIME_FL</A
></TD
><TD
>0x00000080</TD
><TD
>do not update .i_atime</TD
></TR
><TR
><TD
><A
HREF="#EXT2-DIRTY-FL"
>EXT2_DIRTY_FL</A
></TD
><TD
>0x00000100</TD
><TD
>dirty (file is in use?)</TD
></TR
><TR
><TD
><A
HREF="#EXT2-COMPRBLK-FL"
>EXT2_COMPRBLK_FL</A
></TD
><TD
>0x00000200</TD
><TD
>compressed blocks</TD
></TR
><TR
><TD
><A
HREF="#EXT2-NOCOMPR-FL"
>EXT2_NOCOMPR_FL</A
></TD
><TD
>0x00000400</TD
><TD
>access raw compressed data</TD
></TR
><TR
><TD
><A
HREF="#EXT2-ECOMPR-FL"
>EXT2_ECOMPR_FL</A
></TD
><TD
>0x00000800</TD
><TD
>compression error</TD
></TR
><TR
><TD
><A
HREF="#EXT2-BTREE-FL"
>EXT2_BTREE_FL</A
></TD
><TD
>0x00001000</TD
><TD
>b-tree format directory</TD
></TR
><TR
><TD
><A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL</A
></TD
><TD
>0x00001000</TD
><TD
>Hash indexed directory</TD
></TR
><TR
><TD
><A
HREF="#EXT2-IMAGIC-FL"
>EXT2_IMAGIC_FL</A
></TD
><TD
>0x00002000</TD
><TD
>?</TD
></TR
><TR
><TD
><A
HREF="#EXT3-JOURNAL-DATA-FL"
>EXT3_JOURNAL_DATA_FL</A
></TD
><TD
>0x00004000</TD
><TD
>journal file data</TD
></TR
><TR
><TD
><A
HREF="#EXT2-RESERVED-FL"
>EXT2_RESERVED_FL</A
></TD
><TD
>0x80000000</TD
><TD
>reserved for ext2 implementation</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-SECRM-FL"
>5.3.1. EXT2_SECRM_FL - Secure Deletion</A
></H3
><P
>	Enabling this bit will cause random data to be written over the flie's
	content several time before the blocks are unlinked.  Note that this
	is highly implementation dependant and as such, it should not be assumed
	to be 100% secure.  Make sure to study the implementation notes before
	relying on this option.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-UNRM-FL"
>5.3.2. EXT2_UNRM_FL - Record for Undelete</A
></H3
><P
>	When supported by the implementation, setting this bit will cause the
	deleted data to be moved to a temporary location, where the user can
	restore the original file without any risk of data lost.  This is most
	useful when using ext2 on a desktop or workstation.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-COMPR-FL"
>5.3.3. EXT2_COMPR_FL - Compressed File</A
></H3
><P
>	The file's content is compressed.  There is no note about the particular
	algorithm used other than maybe the
	<A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
> field of the
	<A
HREF="#SUPERBLOCK"
>superblock</A
> structure.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-SYNC-FL"
>5.3.4. EXT2_SYNC_FL - Synchronous Updates</A
></H3
><P
>	The file's content in memory will be constantly synchronized with the
	content on disk.  This is mostly used for very sensitive boot files
	or encryption keys that you do not want to lose in case of a crash.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-IMMUTABLE-FL"
>5.3.5. EXT2_IMMUTABLE_FL - Immutable File</A
></H3
><P
>	The blocks associated with the file will not be exchanged.  If for
	any reason a file system defragmentation is launched, such files will
	not be moved. Mostly used for stage2 and stage1.5 boot loaders.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-APPEND-FL"
>5.3.6. EXT2_APPEND_FL - Append Only</A
></H3
><P
>	Writing can only be used to append content at the end of the file and
	not modify the current content.  Example of such use could be mailboxes,
	where anybody could send a message to a user but not modify any already
	present.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-NODUMP-FL"
>5.3.7. EXT2_NODUMP_FL - Do No Dump/Delete</A
></H3
><P
>	Setting this bit will protect the file from deletion.  As long as this
	bit is set, even if the <A
HREF="#I-LINKS-COUNT"
>i_links_count</A
>
	is 0, the file will not be removed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-NOATIME-FL"
>5.3.8. EXT2_NOATIME_FL - Do Not Update .i_atime</A
></H3
><P
>	The <A
HREF="#I-ATIME"
>i_atime</A
> field of the
	<A
HREF="#INODE-STRUCTURE"
>inode</A
> structure will not be modified when the
	file is accessed if this bit is set.  The only good use I can think of
	that are related to security.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-DIRTY-FL"
>5.3.9. EXT2_DIRTY_FL - Dirty</A
></H3
><P
> 	I do not have information at this moment about the use of this bit.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-COMPRBLK-FL"
>5.3.10. EXT2_COMPRBLK_FL - Compressed Blocks</A
></H3
><P
>	This flag is set if one or more blocks are compressed.  You can have
	more information about compression on ext2 at
	http://www.netspace.net.au/~reiter/e2compr/  Note that the project has
	not been updated since 1999.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-NOCOMPR-FL"
>5.3.11. EXT2_NOCOMPR_FL - Access Raw Compressed Data</A
></H3
><P
>	When this flag is set, the file system implementation will not uncompress
	the data before fowarding it to the application but will rather give it as
	is.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-ECOMPR-FL"
>5.3.12. EXT2_ECOMPR_FL - Compression Error</A
></H3
><P
>	This flag is set if an error was detected when trying to uncompress the
	file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-BTREE-FL"
>5.3.13. EXT2_BTREE_FL - B-Tree Format Directory</A
></H3
><P
>	
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-INDEX-FL"
>5.3.14. EXT2_INDEX_FL - Hash Indexed Directory</A
></H3
><P
>	When this bit is set, the format of the directory file is hash indexed.
	This is covered in details in <A
HREF="#INDEXED-DIRECTORY"
>Section 4.2</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-IMAGIC-FL"
>5.3.15. EXT2_IMAGIC_FL -</A
></H3
><P
>    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT3-JOURNAL-DATA-FL"
>5.3.16. EXT2_JOURNAL_DATA_FL - Journal File Data</A
></H3
><P
>    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXT2-RESERVED-FL"
>5.3.17. EXT2_RESERVED_FL - Reserved</A
></H3
><P
>    </P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="AEN2728"
></A
>Appendix A. Credits</H1
><P
>	I would like to personally thank everybody who contributed to this document,
	you are numerous and in many cases I haven't kept track of all of you.  Be
	sure that if you are not in this list, it's a mistake and do not hesitate
	to contact me, it will be a pleasure to add your name to the list.
  </P
><PRE
CLASS="PROGRAMLISTING"
>Peter Rottengatter (Peter.Rottengatter@bakerhughes.com)
  Corrections to <A
HREF="#S-INODES-PER-GROUP"
>Section 3.1.11</A
>
  Corrections to <A
HREF="#DISK-LAYOUT-SAMPLE-FLOPPY"
>Table 3-1</A
> and <A
HREF="#DISK-LAYOUT-SAMPLE-20MB"
>Table 3-2</A
>
  Corrections to <A
HREF="#BLOCK-GROUP-DESCRIPTOR-TABLE"
>Section 3.2</A
>

Ryan Cuthbertson (ryan.cuthbertson@adelaide.edu.au)
  Corrections to <A
HREF="#I-BLOCKS"
>Section 3.5.10</A
>
  Corrections to <A
HREF="#DISK-ORGANISATION"
>Chapter 3</A
>

Andreas Gruenbacher (a.gruenbacher@bestbits.at)
  <A
HREF="#CONTRIB-EXTENDED-ATTRIBUTES"
>Section 5.2</A
>

Daniel Phillips (phillips@innominate.de)
  <A
HREF="#CONTRIB-LOOKUP-ALGORITHM"
>Section 4.2.3</A
>
  <A
HREF="#CONTRIB-INSERT-ALGORITHM"
>Section 4.2.4</A
>
  <A
HREF="#CONTRIB-SPLITTING"
>Section 4.2.5</A
>
  <A
HREF="#CONTRIB-KEY-COLLISIONS"
>Section 4.2.6</A
>
  <A
HREF="#CONTRIB-HASH-FUNCTION"
>Section 4.2.7</A
>
  <A
HREF="#CONTRIB-PERFORMANCE"
>Section 4.2.8</A
>

Jeremy Stanley of Access Data Inc.
  Pointed out the inversed values for EXT2_S_IFSOCK and EXT2_S_IFLNK
  </PRE
></DIV
></DIV
></BODY
></HTML
>